<!DOCTYPE html> <html lang=en > <meta charset=UTF-8  /> <meta name=viewport  content="width=device-width, initial-scale=1" /> <title>Another IDE</title> <meta property="og:url" content="https://aviatesk.github.io/posts/crystal-julia-random-thoughts-20201231" /> <meta property="og:title" content="Another IDE" /> <meta property="og:image" content="https://aviatesk.github.io/assets/what_about_the_dead_fish.jpeg" /> <meta property="og:type" content=article  /> <meta property="og:description" content="Crystal and Juila, random thoughts for next generation of IDE" /> <meta property="og:published_time" content=2020-12-31  /> <meta name="twitter:card" content=summary  /> <meta name="twitter:site" content="@kdwkshh" /> <meta name="twitter:creator" content="@kdwkshh" /> <link rel=stylesheet  href="/libs/highlight/atom-one-light.min.css"> <link rel=icon  href="/assets/what_about_the_dead_fish.jpeg" /> <link rel=stylesheet  href="/css/aviatesk.css" /> <navigation-bar><div class=navigation-info  id=site-info ><a href="/">Shuhei Kadowaki's homepage</a></div></navigation-bar><navigation-bar class=navigation-sticky ><navigation-hover> <a class=navigation-info  id=page-info >$ Another IDE</a> </navigation-hover> <navigation-hover> <img src="/assets/terminal.svg" id=terminal-icon  /> <ul id=site-cd > <li><a style="text-decoration: none" href="/">cd ~</a> <li><a style="text-decoration: none" href="/posts">cd posts</a> <li><a style="text-decoration: none" href="https://github.com/aviatesk">cd <i class="fab fa-github"></i></a> <li><a style="text-decoration: none" href="https://twitter.com/kdwkshh">cd <i class="fab fa-twitter"></i></a> <li><a style="text-decoration: none" href="javascript:history.back()">cd ..</a> </ul> </navigation-hover> </navigation-bar> <div class=franklin-content ><div class=blog-info > <blogtitle>Another IDE</blogtitle> <div class=published-date > 31 December 2020 </div> </div> <p>Today I gave the <a href="https://crystal-lang.org/">Crystal language</a> a try. I was interested in how we can obtain type safety from its Ruby-like, easy and concise syntax. As I wrote more code, I found Crystal coding is somewhat similar to my coding experience with the <a href="https://julialang.org/">Julia language</a>. Well, the reason is clear; there is inter-procedural type inference in both languages, and we don&#39;t need to spread useless type annotations in order to obtain type safety and/or runtime performance, which I believe is quite nice thing.</p> <div class=caption >this simple program can be statically compiled by crystal compiler</div> <pre><code class=language-cr ># we don&#39;t need any annotations like &#96;summer&#40;a : Array&#40;Int32 | Float64&#41;&#41;&#96;
def summer&#40;a&#41;
  ret &#61; 0
  a.each &#123; |e| ret &#43;&#61; e  &#125;
  ret
end

ia &#61; &#91;1, 2, 3&#93;
p summer&#40;ia&#41; # &#61;&gt; 6

fa &#61; &#91;1.0, 2.0, 3.0&#93;
p summer&#40;fa&#41; # &#61;&gt; 6.0</code></pre> <p><a href="https://crystal-lang.org/2014/12/06/another-language.html">This blog post</a> by Ary Borenzweig, one of Crystal&#39;s core devs was about the challenge for such languages: incremental compilation.</p> <p>With the existence of inter-procedural type inference, it&#39;s hard to compile method by method, and so incremental compilation tends to be slow. It also means REPL might not be doable, because a method can&#39;t be compiled without its entry point &#40;i.e. actual argument&#41;. Because of this reason, Crystal doesn&#39;t have REPL yet<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup>.</p> <p>Julia, in turn, is dynamically compiled, i.e. its JIT compilation happens when given the entry point, so we can have a REPL without the problem &#40;well, it&#39;s not just there is a REPL, but rather it&#39;s a quite nice REPL - I don&#39;t know any other REPL that is better than Julia&#39;s&#41;.</p> <p>What about incremental compilation ? I think, in Julia&#39;s context, <a href="https://julialang.org/blog/2020/08/invalidations/">code cache invalidation</a> can be seen as a sort of incremental compilation. The invalidation is triggered on a method refinement so smartly that it only re-compiles as least code as possible &#40;by tracking backeges of compiled method instance while compilation&#41;, but I&#39;d say the problem surely exists &#40;a.k.a. &quot;time to first plot&quot;&#41;. Julia community&#39;s recent approach for this problem is just to try hard to improve the code quality so that we eliminate type-instabilities and prevent future invalidations, which would be positive also in performance perspective. <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile.jl</a> is the primary tool for this, by helping us finding where type-instabilities and invalidations happen.</p> <p>Well, code cache invalidation is rather an essential feature in a dynamic environment like REPL. While statically-compiled languages in general offer fancy IDE environments powered by incremental compilation, but it seems that incremental compilation in the form of compiled code invalidation is not usually realized within their REPL &#40;even if it exists&#41;. E.g. here are examples that Scala and Haskell REPLs don&#39;t seem to update previously-compiled code, but Julia can handle it and works as we expect.<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup>.</p> <div class=caption >compiled code invalidations in REPL</div> <table><p> <tr><p> <th><p>Language</p> <th><p>REPL code</p> </p> <tr><p> <td><p>Scala</p> <td><pre><code class=language-plaintext >❯ sbt consoleQuick
...
&#91;info&#93; welcome to sbt 1.4.4 &#40;AdoptOpenJDK Java 1.8.0_252&#41;
...
Welcome to Scala 2.12.12 &#40;OpenJDK 64-Bit Server VM, Java 1.8.0_252&#41;.
...</code></pre> <pre><code class=language-scala >scala&gt; def inner&#40;a: Int&#41; &#61; Math.sin&#40;a&#41;
inner: &#40;a: Int&#41;Double

scala&gt; def outer&#40;a: Int&#41; &#61; a &#43; inner&#40;a&#41;
outer: &#40;a: Int&#41;Double

scala&gt; outer&#40;1&#41;
res0: Double &#61; 1.8414709848078965

scala&gt; def inner&#40;a: Int&#41; &#61; Math.cos&#40;a&#41; // update &#96;inner&#96;
inner: &#40;a: Int&#41;Double

scala&gt; outer&#40;1&#41; // here we want &#96;outer&#96; to be updated too, but ...
res1: Double &#61; 1.8414709848078965</code></pre> <p></p> </p> <tr><p> <td><p>Haskell</p> <td><pre><code class=language-plaintext >❯ stack ghci
...
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
...</code></pre> <pre><code class=language-haskell >λ&gt; inner &#61; sin
λ&gt; outer a &#61; a &#43; inner a
λ&gt; outer 1
1.8414709848078965
λ&gt; inner &#61; cos -- update &#96;inner&#96;
λ&gt; outer 1 --  here we want &#96;outer&#96; to be updated too, but ...
1.8414709848078965</code></pre> <p></p> </p> <tr><p> <td><p>Julia</p> <td><pre><code class=language-plaintext >❯ julia
               _
   _       _ _&#40;_&#41;_     |  Documentation: https://docs.julialang.org
  &#40;_&#41;     | &#40;_&#41; &#40;_&#41;    |
   _ _   _| |_  __ _   |  Type &quot;?&quot; for help, &quot;&#93;?&quot; for Pkg help.
  | | | | | | |/ _&#96; |  |
  | | |_| | | | &#40;_| |  |  Version 1.7.0-DEV.202 &#40;2020-12-31&#41;
 _/ |\__&#39;_|_|_|\__&#39;_|  |  Commit 1ad6aeddf5 &#40;0 days old master&#41;
|__/                   |</code></pre> <pre><code class=language-julia >julia&gt; inner&#40;a&#41; &#61; sin&#40;a&#41;
inner &#40;generic function with 1 method&#41;

julia&gt; outer&#40;a&#41; &#61; a &#43; inner&#40;a&#41;
outer &#40;generic function with 1 method&#41;

julia&gt; outer&#40;1&#41;
1.8414709848078965

julia&gt; inner&#40;a&#41; &#61; cos&#40;a&#41; # update &#96;inner&#96;
inner &#40;generic function with 1 method&#41;

julia&gt; outer&#40;1&#41; # yay, this is what we want &#33;
1.5403023058681398</code></pre> <p></p> </p> </p> </table> <p>Conversely, we could say Julia&#39;s coding environments other than REPL still don&#39;t make good use of its internal incremental compilation logic &#40;in my opinion, at least&#41;. My idea is that we can re-use it for IDE features with real-time feedbacks.</p> <p>Say if we want fancy IDE features like type level error linting for a dynamic language, but at the same time also want to preserve its easy and simple coding experience. If we have such a tool, we can find an error point or performance pitfall before we actually run the code without scattering type annotations that are only necessary for type checking, like Crystal can ensure type safety of simply-written code at compile time.</p> <p>Such a tool needs some kind of inter-procedural program analysis, rather than the other existing, promised <a href="https://en.wikipedia.org/wiki/Gradual_typing">gradual typing</a> approach<sup id="fnref:3"><a href="#fndef:3" class=fnref >[3]</a></sup>. But as I said above, it will suffer from real-time analysis speed; we will need analysis caching and its incremental invalidation in order to keep the analysis fast enough for real-time feedbacks in IDEs. Fortunately, Julia already has good implementation of type inference and its invalidation system that are originally necessary for the performance and dynamic coding. We can make good use of it to build a next generation of IDE.</p> <p>The idea outlined above is exactly what I&#39;m trying to realize with <a href="https://github.com/aviatesk/JET.jl">JET.jl</a>. I hope I could advance it to a stage where we can use it within VSCode in the next few months.</p> <hr /> <p><table class=fndef  id="fndef:1"> <tr> <td class=fndef-backref ><a href="#fnref:1">[1]</a> <td class=fndef-content ><a href="https://github.com/crystal-lang/crystal/issues/681">https://github.com/crystal-lang/crystal/issues/681</a> </table> <table class=fndef  id="fndef:2"> <tr> <td class=fndef-backref ><a href="#fnref:2">[2]</a> <td class=fndef-content >I guess it&#39;s possibly because the priority of REPL is not so high for developers of those languages ? </table> <table class=fndef  id="fndef:3"> <tr> <td class=fndef-backref ><a href="#fnref:3">[3]</a> <td class=fndef-content >I think the gradual typing approach would be ineffective especially for Julia, because type annotations are about how a generic function dispatches to its method and so are closely related to how it <em>runs</em> rather than just helping a developer understand code. </table> </p> <div class=page-foot > <div class=copyright > &copy; Shuhei Kadowaki. Last modified: 2021-01-01. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script> <script src="/libs/collapsible.js"></script> <script src="/libs/lodash.js"></script> <script src="/libs/onscroll.js"></script> <script> document.ontouchstart = () => {} </script>