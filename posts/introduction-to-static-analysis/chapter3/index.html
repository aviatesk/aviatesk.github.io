<!DOCTYPE html> <html lang=en > <meta charset=UTF-8  /> <meta name=viewport  content="width=device-width, initial-scale=1" /> <title>Chapter 3 â€” A General Static Analysis Framework Based on a Compositional Semantics</title> <meta property="og:url" content="posts/introduction-to-static-analysis/chapter3" /> <meta property="og:title" content="Chapter 3 â€” A General Static Analysis Framework Based on a Compositional Semantics" /> <meta property="og:image" content="assets/what_about_the_dead_fish.jpeg" /> <meta property="og:type" content=article  /> <meta property="og:description" content="A note on "Introduction to Static Analysis", Chapter 3 â€” A General Static Analysis Framework Based on a Compositional Semantics" /> <meta property="og:published_time" content=2021-05-09  /> <meta name="twitter:card" content=summary  /> <meta name="twitter:site" content="@kdwkshh" /> <meta name="twitter:creator" content="@kdwkshh" /> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=icon  href="/assets/what_about_the_dead_fish.jpeg" /> <link rel=stylesheet  href="/css/aviatesk.css" /> <navigation-bar><div class=navigation-info  id=site-info ><a href="/">Shuhei Kadowaki's homepage</a></div></navigation-bar><navigation-bar class=navigation-sticky ><navigation-hover> <a class=navigation-info  id=page-info >$ Chapter 3 â€” A General Static Analysis Framework Based on a Compositional Semantics</a> </navigation-hover> <navigation-hover> <img src="/assets/terminal.svg" id=terminal-icon  /> <ul id=site-cd > <li><a style="text-decoration: none" href="/">cd ~</a> <li><a style="text-decoration: none" href="/posts">cd posts</a> <li><a style="text-decoration: none" href="https://github.com/aviatesk">cd <i class="fab fa-github"></i></a> <li><a style="text-decoration: none" href="https://twitter.com/kdwkshh">cd <i class="fab fa-twitter"></i></a> <li><a style="text-decoration: none" href="javascript:history.back()">cd ..</a> </ul> </navigation-hover> </navigation-bar> <div class=franklin-content ><div class=blog-info > <blogtitle> Chapter 3 â€” A General Static Analysis Framework Based on a Compositional Semantics <a type="application/rss+xml" href="https://aviatesk.github.io/feed.xml" style="float: right"> <i class="fas fa-rss"></i> </a> </blogtitle> <div class=published-date > 09 May 2021 </div> </div> <h2 id=32_abstractions ><a href="#32_abstractions" class=header-anchor >3.2 Abstractions</a></h2> <div class=definition ><div class=admonition-header >Definition: Abstract Domain and Abstraction Relation</div> <div class=admonition-body ><p>We call <em>abstract domain</em> a pair made of a set ğ”¸ and an ordering relation âŠ‘ over that set. Given a concrete domain &#40;â„‚, âŠ†&#41;, an <em>abstraction</em> is defined by an abstract domain &#40;ğ”¸, âŠ‘&#41; and an abstraction relation &#40;âŠ§&#41; âŠ†, â„‚ Ã— ğ”¸, such that,</p> <ul> <li><p>for all \(c \in â„‚, a_0, a_1 \in ğ”¸\), if \(c \models a_0\) and \(a_0 \sqsubseteq a_1\), then \(c \models a_1\)</p> <li><p>for all \(c_0, c_1 âˆˆ â„‚, a âˆˆ ğ”¸\), if \(c_0 \subseteq c_1\) and \(c_1 \models a\), then \(c_0 \models a\)</p> </ul> <p>The first one interpretation: if \(c\) satisfies the property described by the abstract element \(a_0\), and if the abstract element \(a_1\) expresses a weaker property than that expressed by \(a_0\), then \(c\) should also satisfy the abstract property \(a_1\).</p></div></div> <p>A relation \(\models\) is sometimes replaced by &quot;concretization function&quot; and &quot;abstraction function&quot;.</p> <div class=definition ><div class=admonition-header >Definition: Concretization Function</div> <div class=admonition-body >A <em>concretization function</em> &#40;or, for short, <em>concretization</em>&#41; is a function\(\gamma: ğ”¸ â†’ â„‚\) such that, for any abstract element \(a\), \(\gamma(a)\) satisfies \(a\) &#40;i.e., \(\gamma(a) \models a\)&#41; and \(\gamma(a)\) is the maximum element of \(â„‚\) that satisfies \(a\).</div></div> <br/> <div class=definition ><div class=admonition-header >Definition: Abstract Function</div> <div class=admonition-body ><p>Let \(c\) be a concrete element. We say that \(c\) has a best abstraction if and only if there exists an abstract element \(a\) such that</p> <ol> <li><p>\(a\) is an abstraction of \(c\), and</p> <li><p>any other abstraction of \(c\) is greater than \(a\)</p> </ol> <p>If it exists, this element is unique and called the <em>best abstration</em> of \(c\).</p> <p>An <em>abstraction function</em> &#40;or, for short, <em>abstraction</em>&#41; is a function \(\alpha: â„‚ \rightarrow ğ”¸\) that maps each concrete element to its best abstraction.</p></div></div> <p>Notes:</p> <ul> <li><p>either of \(\gamma\) and \(\alpha\) fully describes the underlying abstraction relation</p> </ul> \[ \forall c \in â„‚, a \in ğ”¸, c \models a \Leftrightarrow c \subseteq \gamma(a) \] <ul> <li><p>the existence of a best abstraction function is <strong>not</strong> guaranteed</p> </ul> <div class=definition ><div class=admonition-header >Definition: Galois Connection</div> <div class=admonition-body ><p>A <em>Galois connection</em> is a pair made of a concretization function \(\gamma\) and an abstraction function \(\alpha\) such that</p> \[ \forall c \in â„‚, \forall a \in ğ”¸, \alpha(c) \sqsubseteq a \Leftrightarrow c \subseteq \gamma(a) \]</div></div> <p>Galois connection&#39;s interesting properties:</p> <ul> <li><p>Î± and Î³ are monotone functions , which means that they map logically comparable inputs into logically comparable outputs</p> <li><p>\(\forall c \in â„‚, c \subseteq \gamma(\alpha(c))\) , which means that applying the abstraction function and concretization the result back yield a less precise result &#40;or, equivalently, a conservative approximation&#41;</p> <li><p>\(\forall a \in ğ”¸, \alpha(\gamma(a)) \sqsubseteq a\) , which means that concretizing an abstract element and then abstracting the result back refines the information available in the initial abstract element; this refinement is known as <em>reduction</em></p> </ul> <h3 id=322_non-relational_abstraction ><a href="#322_non-relational_abstraction" class=header-anchor >3.2.2 Non-Relational Abstraction</a></h3> <p>Intuitively, this abstraction</p> <ul> <li><p>treats each variable independently</p> <li><p>applies the value abstraction to each variable separated from the others</p> <li><p>defines the order relation by the <strong>pointwise extension</strong> to abstract elements</p> </ul> <h3 id=323_relational_abstraction ><a href="#323_relational_abstraction" class=header-anchor >3.2.3 Relational Abstraction</a></h3> <blockquote> <p>In general, the choice of an efficient computer representation for abstract domains that describe relational constraints is more difficult than in the case of non-releational abstract domains.</p> </blockquote> <p>Examples:</p> <ul> <li><p>linear equalities</p> <li><p>convex polyhedra</p> <li><p>octagons</p> </ul> <h2 id=33_computable_abstract_semantics ><a href="#33_computable_abstract_semantics" class=header-anchor >3.3 Computable Abstract Semantics</a></h2> <p><img src="./assets/sound-analysis.png" alt="sound analysis" /></p> <div class=caption >sound analysis</div> <ul> <li><p>\([\text{p}]^{\#}_ğ’«\): the static analysis function &#40;<em>abstract semantics</em>&#41;</p> </ul> <p>Abstraction of a sequence of commands: compose each abstraction</p> \[ [C_0;C_1]^{\#}_ğ’«(M^{\#}) = [C_1]^{\#}_ğ’«([C_0]^{\#}_ğ’«(M^{\#})) \] <p>This can be generalized into the following theorem:</p> <div class=theorem ><div class=admonition-header >Theorem: Approximation of Compositions</div> <div class=admonition-body ><p>Let \(F_0, F_1: ğ’«(ğ•„) \rightarrow ğ’«(ğ•„)\) be two monotone functions, and let \(F_0^{\#}, F_1^{\#}: ğ”¸ \rightarrow ğ”¸\) be two functions that over-approximate them, that is such that \(F_0 \circ \gamma \subseteq \gamma \circ F_0^{\#}\) and \(F_1 \circ \gamma \subseteq \gamma \circ F_1^{\#}\). <br /> Then \(F_0 \circ F_1\) can be over-approximated by \(F_0^{\#} \circ F_1^{\#}\).</p> <div class=note ><div class=admonition-header >proof</div> <div class=admonition-body ><ul> <li><p>\(F_1 \circ \gamma \subseteq \gamma \circ F_1^{\#}\) &#40;by the soundness assumption on \(F_1\)&#41;</p> <li><p>\(F_0 \circ F_1 \circ \gamma \subseteq F_0 \circ \gamma \circ F_1^{\#}\) &#40;\(F_0\) is monotone&#41;</p> <li><p>\(F_0 \circ F_1 \circ \gamma \subseteq \gamma \circ F_0^{\#} \circ F_1^{\#}\) &#40;by the soundness assumption on \(F_0\)&#41;</p> </ul></div></div></div></div> <p>Intuitive understanding: we can decompose the over-approximation of a composition of operations into the composition of over-approximations of each operation.</p> <h3 id=abstract_interpretation_of_conditional_branching ><a href="#abstract_interpretation_of_conditional_branching" class=header-anchor >Abstract Interpretation of Conditional Branching</a></h3> <p>Semantics of conditional branching:</p> \[ [\texttt{if}(B)\{C_0\} \texttt{else}\{C_1\}]_ğ’«(M) = [C_0]_ğ’«(â„±_B(M)) \cup [C_1]_ğ’«(â„±_{\neg B}(M)) \] <p>\(â„±_{B}\): returns the memory states in \(M\) such that the condition \(B\) evaluates to <strong>true</strong>.</p> <h4 id=analysis_of_flow_joins ><a href="#analysis_of_flow_joins" class=header-anchor >Analysis of Flow Joins</a></h4> <p>The abstract join operator \(\sqcup^{\#}\) should satisfy the following soundness property</p> \[ \gamma(M_0^{\#}) \cup \gamma(M_1^{\#}) \subseteq \gamma(M_0^{\#} \sqcup^{\#} M_1^{\#}) \] <p>\(\sqcup^{\#}\) can be defined as a pointwise application of a join operator \(\sqcup^{\#}_ğ’±\), which works in the value abstract domain:</p> \[ \text{Fro all variables } \texttt{x}, (M_0^{\#} \sqcup^{\#} M_1^{\#})(x) = M_0^{\#}(x) \sqcup^{\#}_ğ’± M_1^{\#}(x) \] <p>And the definition of \(\sqcup^{\#}_ğ’±\) will really depend on the abstract domain.</p> <h4 id=analysis_of_a_conditional_command ><a href="#analysis_of_a_conditional_command" class=header-anchor >Analysis of a Conditional Command</a></h4> <p>Semantics of conditional branching</p> \[ [\texttt{if}(B)\{C_0\} \texttt{else}\{C_1\}]^{\#}_ğ’«(M^{\#}) = [C_0]^{\#}_ğ’«(â„±_B^{\#}(M^{\#})) \sqcup^{\#} [C_1]^{\#}_ğ’«(â„±_{\neg B}^{\#}(M^{\#})) \] <h3 id=abstract_interpretation_of_loops ><a href="#abstract_interpretation_of_loops" class=header-anchor >Abstract Interpretation of Loops</a></h3> <p>Semantics of loops:</p> \[ [\texttt{while}(B)\{C\}]_ğ’«(M) = â„±_{\neg B} (\cup_{i \ge 0}([C]_ğ’« \circ â„±_B)^i(M)) \] <p>Let \(F = [C]_ğ’« \circ â„±_B\)</p> <ul> <li><p>if the sequence of abstract iterates converges &#40;which can be observed simply by checking that two consecutive iterates are equal&#41;, the its final values over-approximates <em>all</em> the concrete behaviors of the program \(\texttxt{while}(B){C}\)</p> <ul> <li><p><strong>under the assumption that the sequence converges</strong> &#40;&lt;- not always true&#41;</p> </ul> <li><p>&#61;&gt; ensure convergence</p> </ul> <h4 id=convergence_in_finite_height_lattices ><a href="#convergence_in_finite_height_lattices" class=header-anchor >Convergence in Finite Height Lattices</a></h4> <p>Convergence:</p> <ul> <li><p>make the abstract domain has <em>finite height</em>: ensure \(M_k^{\#} âŠ M_{k+1}^{\#}\) cannot hold infinitely many times</p> <ul> <li><p>&#61;&gt; converges when the abstract iteration doesn&#39;t discover any new behavior</p> </ul> <li><p><em>widening</em>: necessary when the abstract domain doesn&#39;t have finite height <div class=definition ><div class=admonition-header >Definition: Widening Operator</div> <div class=admonition-body ><p>A widening operator over an abstract domain ğ”¸ is a binary operator \(\triangledown\), such that</p> <ol> <li><p>for all abstract elements \(a_0, a_1\), we have</p> </ol> \[ \gamma(a_0) \cup \gamma(a_1) \subseteq \gamma(a_0 \triangledown a_1) \] <ol start=2 > <li><p>for all sequences \((a_n)_{n \in â„•}\) of abstract elements, the sequence \((a^\prime_n)_{n \in â„•}\) defined below is ultimately stationary</p> <ul> <li><p>\(a^\prime_0 = a_0\)</p> <li><p>\(a^\prime_{n+1} = a^\prime_n \triangledown a_n\)</p> </ul> </ol></div></div></p> <ul> <li><p>widening could be built by <em>dropping constraints that are not stable</em></p> <ul> <li><p>e.g. interval abstract domain</p> <ul> <li><p>\([n, p] \triangledown [n, q] = [n, p] (\text{if } p \ge q), [n, +\infty) (\text{if } p < q)\)</p> </ul> </ul> </ul> </ul> <h2 id=the_design_of_abstract_interpreter ><a href="#the_design_of_abstract_interpreter" class=header-anchor >The Design of Abstract Interpreter</a></h2> <ul> <li><p>fix the reference concrete semantics</p> <li><p>select the abstraction</p> <li><p>derive analysis algorithms</p> </ul> <div class=page-foot > <div class=copyright > &copy; Shuhei Kadowaki. Last modified: 2021-05-08. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/katex/katex.min.js"></script> <script src="/libs/katex/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script> <script src="/libs/collapsible.js"></script> <script src="/libs/lodash.js"></script> <script src="/libs/onscroll.js"></script> <script> document.ontouchstart = () => {} </script>