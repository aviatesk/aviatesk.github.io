<!DOCTYPE html> <html lang=en > <meta charset=UTF-8  /> <meta name=viewport  content="width=device-width, initial-scale=1" /> <title>Chapter 1 — Program Analysis</title> <meta property="og:url" content="posts/introduction-to-static-analysis/chapter1" /> <meta property="og:title" content="Chapter 1 — Program Analysis" /> <meta property="og:image" content="assets/what_about_the_dead_fish.jpeg" /> <meta property="og:type" content=article  /> <meta property="og:description" content="A note on "Introduction to Static Analysis", Chapter 1 — Program Analysis" /> <meta property="og:published_time" content=2021-04-17  /> <meta name="twitter:card" content=summary  /> <meta name="twitter:site" content="@kdwkshh" /> <meta name="twitter:creator" content="@kdwkshh" /> <link rel=icon  href="/assets/what_about_the_dead_fish.jpeg" /> <link rel=stylesheet  href="/css/aviatesk.css" /> <navigation-bar><div class=navigation-info  id=site-info ><a href="/">Shuhei Kadowaki's homepage</a></div></navigation-bar><navigation-bar class=navigation-sticky ><navigation-hover> <a class=navigation-info  id=page-info >$ Chapter 1 — Program Analysis</a> <div class=franklin-toc ><ol><li><a href="#13_concepts_in_program_analysis"> 1. 1.3 Concepts in Program Analysis</a><li><a href="#14_families_of_program_analysis_techniques"> 2. 1.4 Families of Program Analysis Techniques</a></ol></div> </navigation-hover> <navigation-hover> <img src="/assets/terminal.svg" id=terminal-icon  /> <ul id=site-cd > <li><a style="text-decoration: none" href="/">cd ~</a> <li><a style="text-decoration: none" href="/posts">cd posts</a> <li><a style="text-decoration: none" href="https://github.com/aviatesk">cd <i class="fab fa-github"></i></a> <li><a style="text-decoration: none" href="https://twitter.com/kdwkshh">cd <i class="fab fa-twitter"></i></a> <li><a style="text-decoration: none" href="javascript:history.back()">cd ..</a> </ul> </navigation-hover> </navigation-bar> <div class=franklin-content ><div class=blog-info > <blogtitle> Chapter 1 — Program Analysis <a type="application/rss+xml" href="https://aviatesk.github.io/feed.xml" style="float: right"> <i class="fas fa-rss"></i> </a> </blogtitle> <div class=published-date > 17 April 2021 </div> </div> <h1 id=13_concepts_in_program_analysis ><a href="#13_concepts_in_program_analysis" class=header-anchor >1.3 Concepts in Program Analysis</a></h1> <h2 id=132_static_versus_dynamic ><a href="#132_static_versus_dynamic" class=header-anchor >1.3.2 Static versus Dynamic</a></h2> <p>Motivations for static analysis</p> <ul> <li><p>&quot;before-use&quot; analysis</p> <li><p>analysis of a program that might be never terminating</p> </ul> <h2 id=133_a_hard_limit_uncomputability ><a href="#133_a_hard_limit_uncomputability" class=header-anchor >1.3.3 A Hard Limit: Uncomputability</a></h2> <div class=theorem ><div class=admonition-header >Theorem: Halting problem</div> <div class=admonition-body >The halting problem consists in finding an algorithm <code>halt</code> such that, <div class=theorem-quote >for every program <code>p</code> ∈ 𝙻, <code>halt</code>&#40;<code>p</code>&#41; &#61; <strong>true</strong> <em>if and only if</em> <code>p</code> terminates</div></div></div> <br/> <div class=theorem ><div class=admonition-header >Theorem: Rice theorem</div> <div class=admonition-body >Let 𝙻 be a Turing-complete language, and let 𝒫 be a nontrivial semantic property of programs of 𝙻. There exists no algorithm such that, <div class=theorem-quote >for every program <code>p</code> ∈ 𝙻, it returns <strong>true</strong> <em>if and only if</em> <code>p</code> satisfies the semantic property 𝒫.</div></div></div> <p>So how to design a program analysis ?</p> <ul> <li><p>target a restricted class of programs: give up the &quot;for every program <code>p</code>&quot; part</p> <li><p>not always being able to provide an exact answer: give up the &quot;<em>if and only if</em>&quot; part</p> </ul> <h2 id=135_approximation_soundness_and_completeness ><a href="#135_approximation_soundness_and_completeness" class=header-anchor >1.3.5 Approximation: Soundness and Completeness</a></h2> <p>Let <code>analysis</code> to be an analysis tool to determine whether this property holds: <div class=theorem-quote >for every program <code>p</code> ∈ 𝙻, <code>analysis&#40;p&#41;</code> &#61; <strong>true</strong> ⇔ <code>p</code> satisfies 𝒫.</div> can be decomposed into a pair of implications: <div class=theorem-quote >for every program <code>p</code> ∈ 𝙻, <code>analysis&#40;p&#41;</code> &#61; <strong>true</strong> ⇒ <code>p</code> satisfies 𝒫.<br/> for every program <code>p</code> ∈ 𝙻, <code>analysis&#40;p&#41;</code> &#61; <strong>true</strong> ⇐ <code>p</code> satisfies 𝒫.</div></p> <h2 id=soundness ><a href="#soundness" class=header-anchor >Soundness</a></h2> <p>A <em>sound</em> program analysis satisfies the first implication.</p> <div class=definition ><div class=admonition-header >Definition: Soundness <a id=soundness  class=anchor ></a></div> <div class=admonition-body >The program analyzer <code>analysis</code> is <em>sound</em> with respect to property 𝒫 whenever, for any program <code>p</code> ∈ 𝙻, <code>analysis&#40;p&#41;</code> &#61; <strong>true</strong> implies that <code>p</code> satisfies property 𝒫.</div></div> <p>A sound analysis will reject all programs that do not satisfy 𝒫.</p> <div class=example ><div class=admonition-header >Example: Strong Typing</div> <div class=admonition-body ><ul> <li><p>good: well-typed programs will not present certain classes of errors</p> <li><p>bad: certain programs that will never crash may still be rejected</p> </ul></div></div> <p>The soundness is easy to meet; we can simply reject any program. Therefore, in practice, the design of a sound analysis will try to give a conclusive answer as often as possible.</p> <h2 id=completeness ><a href="#completeness" class=header-anchor >Completeness</a></h2> <div class=definition ><div class=admonition-header >Definition: Completeness</div> <div class=admonition-body >The program analyzer <code>analysis</code> is <em>complete</em> with respect to property 𝒫 whenever, for every program <code>p</code> ∈ 𝙻, such that <code>p</code> satisfies 𝒫, <code>analysis&#40;p&#41;</code> &#61; <strong>true</strong>.</div></div> <p>The completeness is also easy to meet; we can simply never reject any program. To be useful, a complete analyzer should often reject programs that don&#39;t satisfy the property of interest.</p> <h2 id=soundness_vs_completeness ><a href="#soundness_vs_completeness" class=header-anchor >Soundness vs. Completeness</a></h2> <p><img src="./assets/soundness-vs-completeness.png" alt=soundness-vs-completeness  /></p> <div class=caption >Soundness vs. Completeness &#40;adapted from Figure 1.2 from the book&#41;</div> <p>When a program analysis is automatic, it is either unsound or incomplete.</p> <h1 id=14_families_of_program_analysis_techniques ><a href="#14_families_of_program_analysis_techniques" class=header-anchor >1.4 Families of Program Analysis Techniques</a></h1> <ul> <li><p><em><strong>Testing</strong></em>: check a finite set of finite program executions</p> <ul> <li><p>unsound and complete</p> <li><p>good: easy, very close to the actual runtime</p> <li><p>bad: may not terminate, may not be deterministic &#40;e.g. concurrent programs&#41;, not feasible to fully observe all executions</p> <li><p>xref: <a href="https://en.wikipedia.org/wiki/Concolic_testing">concolic testing</a> to improve coverage and accuracy</p> </ul> <li><p><em><strong>Assisted Proof</strong></em>: rely on user-supplied invariants</p> <ul> <li><p>2 basic approaches:</p> <ul> <li><p>based on theorem-proving tools &#40;e.g. <a href="https://coq.inria.fr/">Coq</a>&#41;</p> <li><p>leverages a tool infrastructure to prove a specific set of properties over programs in a specific language &#40;e.g. <a href="https://github.com/dafny-lang/dafny">dafny</a>&#41;</p> </ul> <li><p>good: often sound to respect to the model of the program semantics used for the proof, also complete up to the abilities of the proof assistant to verify proofs</p> <li><p>bad: non-automated, requires significant time and expertise</p> </ul> <li><p><em><strong>&#40;Finite-State&#41; Model Checking</strong></em>: exhaustive exploration of finite systems</p> <ul> <li><p>use some kind of exhaustive &#40;but efficient&#41; enumeration and determine whether all executions satisfy the property of interest</p> <li><p>good: automatic, sound and complete <em>with respect to the model</em></p> <li><p>caveat: verification is performed at the model level and not at the program level</p> <ul> <li><p>a model of the program needs to be constructed &#40;manually or by some automatic frontend means&#41;</p> <li><p>&#61;&gt; the checking of the synthesized model may be either incomplete or unsound, <em>with respect to the input program</em> &#40;incompleteness or unsoundness is often introduced in the modeling stage&#41;</p> </ul> <li><p>often conservative: sound and incomplete with respect to the input program</p> </ul> <li><p><em><strong>Conservative Static Analysis</strong></em>: automatic, sound, and incomplete approach</p> <ul> <li><p>idea: finitely over-approximate the set of all program behaviors using a specific set of properties</p> <li><p>many existing trials</p> <ul> <li><p><a href="https://www.absint.com/astree/index.htm">Astrée</a>: proves the absence of run-time errors in embedded C codes</p> <li><p><a href="https://github.com/facebook/infer">Infer</a>: detects memory issues in C/C&#43;&#43;/Java programs</p> <li><p><a href="https://www.verifysoft.com/en_julia_static_analyzer.html">JULIA</a>: discovers security issues in Java programs</p> </ul> <li><p>often sound and incomplete</p> <li><p>we can think of unsound and complete static analysis</p> <ul> <li><p>will answer very different kind of question</p> <li><p>may guarantee that a given subset of the executions of the program can be observed, while it doesn&#39;t prove properties such as the absence of run-time errors</p> </ul> </ul> <li><p><em><strong>bug finding</strong></em>: Relaxed error search, automatic, unsound, incomplete, based on heuristics</p> <ul> <li><p>simplify the design and implementation of analysis tools and to provide lighter-weight verification algorithms</p> <li><p>can be used to improve the quality of non-critical programs at a low cost</p> <li><p>examples:</p> <ul> <li><p><a href="https://github.com/aviatesk/JET.jl">JET.jl</a>: JET is unsound and incomplete bug finder for Julia, thus falls into this category &#40;as of now, at least&#41;</p> <li><p><a href="https://www.cprover.org/cbmc/">CBMC</a>: extracts models from C/C&#43;&#43;/Java programs and performs bounded model checking &#40;i.e. explores models only up to fixed depths&#41;</p> </ul> </ul> </ul> <table><p> <tr><p> <th> <th><p>automatic</p> <th><p>soundness</p> <th><p>completeness</p> <th><p>object</p> <th><p>when</p> </p> <tr><p> <td><p>testing</p> <td><p>No</p> <td><p>No</p> <td><p>Yes</p> <td><p>Program</p> <td><p>Dynamic</p> </p> <tr><p> <td><p>Assisted Proof</p> <td><p>No</p> <td><p>Yes</p> <td><p>Yes/No</p> <td><p>Model</p> <td><p>Static</p> </p> <tr><p> <td><p>Model Checking of finite-state model</p> <td><p>Yes</p> <td><p>Yes</p> <td><p>Yes</p> <td><p>Finite Model</p> <td><p>Static</p> </p> <tr><p> <td><p>Model Checking at program level</p> <td><p>Yes</p> <td><p>Yes</p> <td><p>No</p> <td><p>Program</p> <td><p>Static</p> </p> <tr><p> <td><p>Conservative Static Analysis</p> <td><p>Yes</p> <td><p>Yes</p> <td><p>No</p> <td><p>Program</p> <td><p>Static</p> </p> <tr><p> <td><p>bug finding</p> <td><p>Yes</p> <td><p>No</p> <td><p>No</p> <td><p>Program</p> <td><p>Static</p> </p> </p> </table> <div class=caption >an overview of program analysis techniques</div> <div class=page-foot > <div class=copyright > &copy; Shuhei Kadowaki. Last modified: 2021-06-01. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/libs/collapsible.js"></script> <script src="/libs/lodash.js"></script> <script src="/libs/onscroll.js"></script> <script> document.ontouchstart = () => {} </script>