<!DOCTYPE html> <html lang=en > <meta charset=UTF-8  /> <meta name=viewport  content="width=device-width, initial-scale=1" /> <title>A quick dive into Julia's type inference algorithm</title> <meta property="og:url" content="posts/data-flow-problem" /> <meta property="og:title" content="A quick dive into Julia's type inference algorithm" /> <meta property="og:image" content="assets/what_about_the_dead_fish.jpeg" /> <meta property="og:type" content=article  /> <meta property="og:description" content="introduction to dataflow analysis and Julia's local type inference routine" /> <meta property="og:published_time" content=2020-11-09  /> <meta name="twitter:card" content=summary  /> <meta name="twitter:site" content="@kdwkshh" /> <meta name="twitter:creator" content="@kdwkshh" /> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/atom-one-light.min.css"> <link rel=icon  href="/assets/what_about_the_dead_fish.jpeg" /> <link rel=stylesheet  href="/css/aviatesk.css" /> <navigation-bar><div class=navigation-info  id=site-info ><a href="/">Shuhei Kadowaki's homepage</a></div></navigation-bar><navigation-bar class=navigation-sticky ><navigation-hover> <a class=navigation-info  id=page-info >$ A quick dive into Julia's type inference algorithm</a> <div class=franklin-toc ><ol><li><a href="#algorithm"> 1. Algorithm</a><li><a href="#implementation"> 2. Implementation</a><li><a href="#compare_with_julias_native_type_inference"> 3. Compare with Julia&#39;s native type inference</a><li><a href="#conclusion"> 4. Conclusion</a><li><a href="#references"> 5. References</a><li><a href="#footnotes"> 6. Footnotes</a></ol></div> </navigation-hover> <navigation-hover> <img src="/assets/terminal.svg" id=terminal-icon  /> <ul id=site-cd > <li><a style="text-decoration: none" href="/">cd ~</a> <li><a style="text-decoration: none" href="/posts">cd posts</a> <li><a style="text-decoration: none" href="https://github.com/aviatesk">cd <i class="fab fa-github"></i></a> <li><a style="text-decoration: none" href="https://twitter.com/kdwkshh">cd <i class="fab fa-twitter"></i></a> <li><a style="text-decoration: none" href="javascript:history.back()">cd ..</a> </ul> </navigation-hover> </navigation-bar> <div class=franklin-content ><div class=blog-info > <blogtitle> A quick dive into Julia's type inference algorithm <a type="application/rss+xml" href="https://aviatesk.github.io/feed.xml" style="float: right"> <i class="fas fa-rss"></i> </a> </blogtitle> <div class=published-date > 09 November 2020 </div> </div> <p>In this article we&#39;ll try to understand and implement a part of <a href="https://julialang.org/">Julia</a>&#39;s inference algorithm. The technique is commonly called as &quot;abstract interpretation&quot; or &quot;data-flow analysis&quot; of a program, which is generally used for program analysis, and so I hope even those who aren&#39;t especially interested in Julia may find this interesting.</p> <p>In this article we&#39;re going to pick up <a href="https://en.wikipedia.org/wiki/Constant_folding">constant folding propagation</a> as an example data-flow analysis problem, and actually implement it from scratch using Julia. While constant folding propagation is one of the most common compiler optimization technique, the understanding can be easily generalized and the example implementation will help you figure out how Julia&#39;s inference routine works.</p> <div class=franklin-toc ><ol><li><a href="#algorithm">Algorithm</a><ol><li><a href="#data-flow_problem">Data-flow problem</a><li><a href="#a_graph-free_approach_to_data-flow_analysis">&quot;A Graph-Free Approach to Data-Flow Analysis&quot;</a><li><a href="#example_problem_constant_folding_propagation">Example problem: Constant folding propagation</a><li><a href="#the_graph-free_algorithm">The graph-free algorithm</a><li><a href="#example_program_prog0_and_example_algorithm_tracing">Example program <code>prog0</code> and example algorithm tracing</a></ol><li><a href="#implementation">Implementation</a><ol><li><a href="#example_problem_constant_folding_propagation_example">Example problem: Constant folding propagation example</a><li><a href="#example_program_prog0">Example program <code>prog0</code></a><li><a href="#the_graph-free_algorithm__2">The graph-free algorithm</a><li><a href="#debugging_the_papers_algorithm">Debugging the paper&#39;s algorithm</a><li><a href="#the_modified_version_of_the_graph-free_algorithm">The modified version of the graph-free algorithm</a></ol><li><a href="#compare_with_julias_native_type_inference">Compare with Julia&#39;s native type inference</a><ol><li><a href="#try_it_first">Try it first</a><li><a href="#check_the_fixes_in_julias_type_inference_implementation">Check the fixes in Julia&#39;s type inference implementation</a></ol><li><a href="#conclusion">Conclusion</a><li><a href="#references">References</a><li><a href="#footnotes">Footnotes</a></ol></div> <h1 id=algorithm ><a href="#algorithm" class=header-anchor >Algorithm</a></h1> <p>In this section we will briefly introduce some notations to describe a general data-flow analysis and consider the example problem &#40;constant folding propagation&#41;, and finally understand an algorithm to solve it.</p> <h2 id=data-flow_problem ><a href="#data-flow_problem" class=header-anchor >Data-flow problem</a></h2> <p>A <span class=bibref ><a href="#dataflowprob">data-flow problem</a></span> is defined by the following 4 components:</p> <ol> <li><p>\(P = I_0 ... I_n \in \text{Instr}\): a program, which consists of &quot;instructions&quot;</p> <li><p>\(L = < A, \sqcup, \sqcap >\) : <a href="https://en.wikipedia.org/wiki/Lattice_&#40;order&#41;">lattice</a> of abstract state that represents some property of \(P\)</p> <li><p>\(![.!] : \text{Instr} \rightarrow (A \rightarrow A)\): &quot;abstract semantics&quot; of \(P\), which gives how each instruction acts on \(P\)&#39;s abstract state \(A\)</p> <li><p>\(a_0 \in A\): initial state of \(P\)</p> </ol> <p>where:</p> <ul> <li><p>\(\text{Instr}\): basic instructions that make up a program; we can think of any kind of instruction as far as we can distinguish between instructions that cause the control flow to branch and those which keep the control flow linear</p> <li><p>\(A\): set that represents program&#39;s state<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup></p> <li><p>\(\sqcup, \sqcap\): operations corresponding to <a href="https://en.wikipedia.org/wiki/Join_and_meet">join and meet</a> respectively, that acts on \(A\)</p> </ul> <p>The actual and concrete definitions of \(P\), \(L\), and \(![.!]\) are given for each data-flow problem.</p> <h2 id=a_graph-free_approach_to_data-flow_analysis ><a href="#a_graph-free_approach_to_data-flow_analysis" class=header-anchor >&quot;A Graph-Free Approach to Data-Flow Analysis&quot;</a></h2> <p><span class=bibref ><a href="#bbgraph">Muchnick, S.S. and Jones, N.D., 1981. Program flow analysis: Theory and applications (Vol. 196)</a></span> proposed an algorithm that uses a graph that has nodes of <a href="https://en.wikipedia.org/wiki/Basic_block">basic blocks</a> &#40;&quot;BB graph&quot;&#41; as a core data structure, and it had been the <em>de facto</em> standard algorithm to solve a data-flow problem.</p> <p><span class=bibref ><a href="#graphfree">Mohnen, M., 2002, April. A graph-free approach to data-flow analysis</a></span> extended that algorithm so that it doesn&#39;t use a graph as an explicit data structure.</p> <p>It experimentally showed that the &quot;graph-free&quot; approach has the following benefits:</p> <ul> <li><p>improved memory efficiency: in many cases, it&#39;s able to reduce the memory usage by a third, at the cost of negligible execution time trade-offs</p> <li><p>easy to implement: it no longer needs to build a BB graph</p> </ul> <p>To help us understand the algorithm proposed in the paper, let&#39;s introduce an example data-flow problem first.</p> <div class=note ><div class=admonition-header >Reference note</div> <div class=admonition-body >In the rest of this article, I&#39;m going to refer to <span class=bibref ><a href="#graphfree">Mohnen, M., 2002, April. A graph-free approach to data-flow analysis</a></span> as &quot;the paper&quot;.</div></div> <h2 id=example_problem_constant_folding_propagation ><a href="#example_problem_constant_folding_propagation" class=header-anchor >Example problem: Constant folding propagation</a></h2> <p>This article picks up <a href="https://en.wikipedia.org/wiki/Constant_folding">constant folding propagation</a> as an example data-flow problem. It is a common compiler optimization technique that aims at finding as many constants as possible at compile time, and replacing the runtime computations with the constant values. So the data-flow problem for that is setup up such that it determines if a variable is constant or not at each point of the program.</p> <p>Let&#39;s get started with defining 1.&#41; program \(P\), 2.&#41; lattice \(L\), 3.&#41; abstract semantics \(![.!]\), and 4.&#41; the initial state \(a_0\).</p> <h3 id=problem_setting_1_program_p ><a href="#problem_setting_1_program_p" class=header-anchor >Problem setting 1: Program \(P\)</a></h3> <p>For the sake of simplicity, we will assume that the program \(P\) only performs operations on integers and there&#39;re only three types of instruction:</p> <ul> <li><p>assignment: <code>lhs :&#61; rhs</code></p> <li><p>unconditional branching: <code>goto instruction</code></p> <li><p>conditional branching: <code>condition &amp;&amp; goto instruction</code></p> </ul> <h3 id=problem_setting_2_lattice_l ><a href="#problem_setting_2_lattice_l" class=header-anchor >Problem setting 2: Lattice \(L\)</a></h3> <p>Let \(C\) to be an abstract value that represents each variable&#39;s property. For constant folding prop&#39;, we only need to consider the following three kinds of \(C\):</p> <ul> <li><p>\(\top\): the top element of lattice</p> <li><p>\(c \in \mathbb{N}\): constant</p> <li><p>\(\bot\): the bottom element of lattice</p> </ul> <p>The paper gave intuitive meanings of \(\top\) and \(\bot\) as follows:</p> <ul> <li><p>\(\top\): &quot;non constant due to <em>missing information</em>&quot;</p> <li><p>\(\bot\): &quot;non constant due to <em>conflict</em>&quot;</p> </ul> <p>Next, we define the ordering of \(C\) as follows: \(c_1 \le c_2\) iff a&#41; \(c_1 = c_2\), b&#41; \(c_1 = \bot\), c&#41; \(c_2 = \top\)</p> <p>So \(C\) forms the flat lattice as shown in the following image: <img src="./assets/lattice.png" alt=lattice  /></p> <div class=caption >Hasse diagram of \(< C, \sqcup, \sqcap > \)</div> <p>The abstract state \(A\) for each instruction of \(P\) can be represented as the following map, where \(X\) is the set of variables in \(P\):</p> \[ A := X \rightarrow C \] <p>Finally, we can think of meet and join operations on abstract state \(A\) &#40;\(\sqcap_A\), \(\sqcup_A\)&#41; as the per-variable uses of corresponding operation on abstract value \(C\).</p> <h3 id=problem_setting_3_abstract_semantics ><a href="#problem_setting_3_abstract_semantics" class=header-anchor >Problem setting 3: Abstract semantics \(![.!]\)</a></h3> <p>Let&#39;s consider the abstract semantics \(![.!]\) of program \(P\). Each instruction of \(P\) has the following effect on abstract state:</p> <ul> <li><p>assignment &#40;<code>lhs :&#61; rhs</code>&#41;: assigns <code>rhs</code> to <code>lhs</code> only when <code>rhs</code> is known to be constant, otherwise assign \(\bot\) to <code>lhs</code></p> <li><p>unconditional branching &#40;<code>goto instruction</code>&#41;: doesn&#39;t change the abstract state</p> <li><p>conditional branching &#40;<code>condition &amp;&amp; goto instruction</code>&#41;: doesn&#39;t change the abstract state</p> </ul> <div class=caption >Abstract semantics \(![.!] \)</div> <h3 id=problem_setting_4_initial_program_state_a_0_a_idinitial-state_classanchor ><a href="#problem_setting_4_initial_program_state_a_0_a_idinitial-state_classanchor" class=header-anchor >Problem setting 4: Initial program state \(a_0\) <a id=initial-state  class=anchor ></a></a></h3> <p>While the paper explains that the initial state of program in constant folding prop&#39; problem should be initialized with \(\bot\), it&#39;s probably wrong. Rather, \(P\) should be initialized with \(\top\) for this problem; Intuitively, at the initial state, each variable in \(P\) should be interpreted as &quot;non constant due to <em>missing information</em>&quot; rather than &quot;non constant due to <em>conflict</em>&quot;.</p> \[ a_0 := X \rightarrow \top \] <h2 id=the_graph-free_algorithm ><a href="#the_graph-free_algorithm" class=header-anchor >The graph-free algorithm</a></h2> <p>Now we&#39;ve set up the data-flow problem. The paper proposed the following algorithm to solve it: <sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup></p> <p><img src="./assets/algorithm.png" alt="the graph-free algorithm" /></p> <div class=caption >The graph-free algorithm</div> <p>Intuitive understandings of this algorithm are:</p> <ol> <li><p>the program itself acts on its abstract state at instruction level via abstract semantics \(![.!]\)</p> <li><p>the algorithm works by updating the current program counter \(pc\), which corresponds to the current instruction \(I_{pc}\), and the working set \(W\), which holds the rest of the instructions to be computed</p> <li><p>the abstract state of the current instruction \(I_{pc}\) propagates to states of all the instructions that \(I_{pc}\) may reach</p> <li><p>however, the abstract state of the current instruction \(I_{pc}\) propagates only if it &quot;changes&quot; the abstract state of an instruction to which it propagates</p> </ol> <p> 3. corresponds to \(I_{pc} = (\text{if} \psi \text{goto} l)\) in the algorithm. This means, the algorithm accounts for both branches at the conditional branching, unlike the actual program execution.</p> <p> 4. corresponds to \(\text{if} new < s_{pc'}\) and \(\text{if} new < s_{l}\) in the algorithm. The paper uses the ordering relation \(<\) of the abstract state \(A\) in the lattice \(L\) as the condition to check whether or not the abstract state of the current instruction &quot;changes&quot; the abstract state of an instruction to which it propagates. In other word, if \(new < s_{pc'}\) doesn&#39;t hold we consider the abstract state has &quot;converged&quot; &#40;and finally the algorithm will terminate after all the abstract states for each instruction have converged&#41;. The paper also explains that the ordering relation \(<\) is equivalent to the following condition:</p> <a id=strict_ordering_relation_between_abstract_states  class=anchor ></a>\[ new < s_{pc'} \equiv (new \sqcap s_{pc'} = new) \land (new \ne s_{pc'}) \] <p>That is, \(new\) &#40;abstract state of the current instruction \(I_{pc}\)&#41; is propagated to \(s_{pc'}\) &#40;abstract state of the next instruction \(I_{pc'}\)&#41; only when \(new\) is lower than \(s_{pc'}\) in the lattice \(L\)<sup id="fnref:3"><a href="#fndef:3" class=fnref >[3]</a></sup>. Thus, the abstract state \(A\) for each instruction is <em>always</em> updated in a way that it transitions towards the bottom of \(L\), so that this algorithm will always converge given lattice \(L\) with finite height.</p> <h2 id=example_program_prog0_and_example_algorithm_tracing ><a href="#example_program_prog0_and_example_algorithm_tracing" class=header-anchor >Example program <code>prog0</code> and example algorithm tracing</a></h2> <p>As an concrete example of the program \(P\), suppose we have the following program <code>prog0</code>:</p> <pre><code class=language-plaintext >0 ─ I₀ &#61; x :&#61; 1
│   I₁ &#61; y :&#61; 2
│   I₂ &#61; z :&#61; 3
└── I₃ &#61; goto I₈
1 ─ I₄ &#61; r :&#61; y &#43; z
└── I₅ &#61; if x ≤ z goto I₇
2 ─ I₆ &#61; r :&#61; z &#43; y
3 ─ I₇ &#61; x :&#61; x &#43; 1
4 ─ I₈ &#61; if x &lt; 10 goto I₄</code></pre> <div class=caption >Example program: <code>prog0</code></div> <p>&#40;The leftmost numbers correspond to basic blocks. They&#39;re not used by the algorithm presented in this article.&#41;</p> <p>The paper shows the following tables as the example tracing of the algorithm running on <code>prog0</code>: <a id=tracing-example  class=anchor ></a> <img src="./assets/tracing-example.png" alt=tracing-example  /></p> <div class=caption >The paper&#39;s tracing example on <code>@prog0</code></div> <p>We can see that at the final state \(s_8\) &#40;\(\text{x}/\bot \text{y}/2 \text{z}/3 \text{r}/5\)&#41;, the algorithm obtains the information that &quot;<code>r</code> is a constant <code>5</code>&quot;, which doesn&#39;t appear in <code>prog0</code>.</p> <h1 id=implementation ><a href="#implementation" class=header-anchor >Implementation</a></h1> <p>Phew, such a long preface. Now let&#39;s express the data-flow problem and implement the algorithm using Julia &#33; As in the previous section, we first setup the problem, and then tackle the algorithm. The full code can be found at <a href="https://github.com/aviatesk/aviatesk.github.io/blob/main/posts/data-flow-problem/assets/dataflow.jl">https://github.com/aviatesk/aviatesk.github.io/blob/main/posts/data-flow-problem/assets/dataflow.jl</a>.</p> <div class=note ><div class=admonition-header >Acknowledgement</div> <div class=admonition-body >The code below was originally adapted from <a href="https://github.com/JeffBezanson/dataflow.jl/blob/c21a6737a8d877c244bef590d207d868f6744d3a/dataflow.jl">https://github.com/JeffBezanson/dataflow.jl/blob/c21a6737a8d877c244bef590d207d868f6744d3a/dataflow.jl</a> under the MIT license.</div></div> <h2 id=example_problem_constant_folding_propagation_example ><a href="#example_problem_constant_folding_propagation_example" class=header-anchor >Example problem: Constant folding propagation example</a></h2> <h3 id=problem_setting_1_program_p__2 ><a href="#problem_setting_1_program_p__2" class=header-anchor >Problem setting 1: Program \(P\)</a></h3> <pre><code class=language-julia >abstract type Exp end

struct Sym &lt;: Exp
    name::Symbol
end

struct Num &lt;: Exp
    val::Int
end

struct Call &lt;: Exp
    head::Sym
    args::Vector&#123;Exp&#125;
end

abstract type Instr end

struct Assign &lt;: Instr
    lhs::Sym
    rhs::Exp
end

struct Goto &lt;: Instr
    label::Int
end

struct GotoIf &lt;: Instr
    label::Int
    cond::Exp
end

const Program &#61; Vector&#123;Instr&#125;</code></pre></p> <p><pre><code class="plaintext code-output">Vector{Instr} (alias for Array{Instr, 1})</code></pre>
<h3 id=problem_setting_2_lattice_l__2 ><a href="#problem_setting_2_lattice_l__2" class=header-anchor >Problem setting 2: Lattice \(L\)</a></h3>
<p>Now we will express the abstract state \(A := X \rightarrow C\) of an instruction that composes program \(P\).</p>
<p>First, we define \(C\), abstract value that a variable \(X\) can have, and their order: <pre><code class=language-julia ># partial order, meet, join, top, bottom, and their identities

import Base: ≤, &#61;&#61;, &lt;, show

abstract type LatticeElement end

struct Const &lt;: LatticeElement
    val::Int
end

struct TopElement &lt;: LatticeElement end
struct BotElement &lt;: LatticeElement end

const ⊤ &#61; TopElement&#40;&#41;
const ⊥ &#61; BotElement&#40;&#41;

show&#40;io::IO, ::TopElement&#41; &#61; print&#40;io, &#39;⊤&#39;&#41;
show&#40;io::IO, ::BotElement&#41; &#61; print&#40;io, &#39;⊥&#39;&#41;

≤&#40;x::LatticeElement, y::LatticeElement&#41; &#61; x≡y
≤&#40;::BotElement,      ::TopElement&#41;      &#61; true
≤&#40;::BotElement,      ::LatticeElement&#41;  &#61; true
≤&#40;::LatticeElement,  ::TopElement&#41;      &#61; true

# NOTE: &#61;&#61; and &lt; are defined such that future LatticeElements only need to implement ≤
&#61;&#61;&#40;x::LatticeElement, y::LatticeElement&#41; &#61; x≤y &amp;&amp; y≤x
&lt;&#40;x::LatticeElement,  y::LatticeElement&#41; &#61; x≤y &amp;&amp; &#33;&#40;y≤x&#41;

# join
⊔&#40;x::LatticeElement, y::LatticeElement&#41; &#61; x≤y ? y : y≤x ? x : ⊤

# meet
⊓&#40;x::LatticeElement, y::LatticeElement&#41; &#61; x≤y ? x : y≤x ? y : ⊥</code></pre></p>
<p><pre><code class="plaintext code-output">⊓ (generic function with 1 method)</code></pre></p>
<p>Next, let&#39;s represent abstract state \(A\) as map from variable \(X\) to its abstract value \(C\), and define its ordering relation \(<\): <pre><code class=language-julia ># NOTE: the paper &#40;https://api.semanticscholar.org/CorpusID:28519618&#41; uses U&#43;1D56E MATHEMATICAL BOLD FRAKTUR CAPITAL C for this
const AbstractState &#61; Dict&#123;Symbol,LatticeElement&#125;

# extend lattices of abstract values to lattices of mappings of variables to abstract values;
# ⊓ and ⊔ operate pair-wise, and from there we can just rely on the Base implementation for
# dictionary equality comparison

⊔&#40;X::AbstractState, Y::AbstractState&#41; &#61; AbstractState&#40; v &#61;&gt; X&#91;v&#93; ⊔ Y&#91;v&#93; for v in keys&#40;X&#41; &#41;
⊓&#40;X::AbstractState, Y::AbstractState&#41; &#61; AbstractState&#40; v &#61;&gt; X&#91;v&#93; ⊓ Y&#91;v&#93; for v in keys&#40;X&#41; &#41;

&lt;&#40;X::AbstractState, Y::AbstractState&#41; &#61; X⊓Y&#61;&#61;X &amp;&amp; X≠Y</code></pre></p>
<p><pre><code class="plaintext code-output">< (generic function with 77 methods)</code></pre></p>
<h3 id=problem_setting_3_abstract_semantics__2 ><a href="#problem_setting_3_abstract_semantics__2" class=header-anchor >Problem setting 3: Abstract semantics \(![.!]\)</a></h3>
<p>Abstract semantics \(![.!]\) can be easily implemented using Julia&#39;s actual code execution. We can use <a href="https://docs.julialang.org/en/v1/base/base/#Core.getfield"><code>getfield</code></a> and easily retrieve the actual arithmetic function from <code>head::Symbol</code> field of <code>Call</code> object.</p>
<pre><code class=language-julia >abstract_eval&#40;x::Num, s::AbstractState&#41; &#61; Const&#40;x.val&#41;

abstract_eval&#40;x::Sym, s::AbstractState&#41; &#61; get&#40;s, x.name, ⊥&#41;

function abstract_eval&#40;x::Call, s::AbstractState&#41;
    f &#61; getfield&#40;@__MODULE__, x.head.name&#41;

    argvals &#61; Int&#91;&#93;
    for arg in x.args
        arg &#61; abstract_eval&#40;arg, s&#41;
        arg &#61;&#61;&#61; ⊥ &amp;&amp; return ⊥ # bail out if any of call arguments is non-constant
        push&#33;&#40;argvals, unwrap_val&#40;arg&#41;&#41;
    end

    return Const&#40;f&#40;argvals...&#41;&#41;
end

# unwrap our lattice representation into actual Julia value
unwrap_val&#40;x::Num&#41;   &#61; x.val
unwrap_val&#40;x::Const&#41; &#61; x.val</code></pre></p>
<p><pre><code class="plaintext code-output">unwrap_val (generic function with 2 methods)</code></pre>
<h3 id=problem_setting_4_initial_program_state_a_0 ><a href="#problem_setting_4_initial_program_state_a_0" class=header-anchor >Problem setting 4: Initial program state \(a_0\)</a></h3>
<p>As explained in <a href="#initial-state">the previous section</a>, we modify the example in the article and initialize \(a_0\) with \(\top\): <pre><code class=language-julia >a₀ &#61; AbstractState&#40;:x &#61;&gt; ⊤, :y &#61;&gt; ⊤, :z &#61;&gt; ⊤, :r &#61;&gt; ⊤&#41;</code></pre></p>
<p><pre><code class="plaintext code-output">Dict{Symbol, LatticeElement} with 4 entries:
  :y => ⊤
  :z => ⊤
  :r => ⊤
  :x => ⊤</code></pre></p>
<h2 id=example_program_prog0 ><a href="#example_program_prog0" class=header-anchor >Example program <code>prog0</code></a></h2>
<p>Before implementing the algorithm, let&#39;s represent the example program <code>prog0</code> first.</p>
<p>An naive representation would look like this: <pre><code class=language-julia >prog0 &#61; &#91;Assign&#40;Sym&#40;:x&#41;, Num&#40;1&#41;&#41;,                              # I₀
         Assign&#40;Sym&#40;:y&#41;, Num&#40;2&#41;&#41;,                              # I₁
         Assign&#40;Sym&#40;:z&#41;, Num&#40;3&#41;&#41;,                              # I₂
         Goto&#40;8&#41;,                                              # I₃
         Assign&#40;Sym&#40;:r&#41;, Call&#40;Sym&#40;:&#40;&#43;&#41;&#41;, &#91;Sym&#40;:y&#41;, Sym&#40;:z&#41;&#93;&#41;&#41;, # I₄
         GotoIf&#40;7, Call&#40;Sym&#40;:&#40;≤&#41;&#41;, &#91;Sym&#40;:x&#41;, Sym&#40;:z&#41;&#93;&#41;&#41;,       # I₅
         Assign&#40;Sym&#40;:r&#41;, Call&#40;Sym&#40;:&#40;&#43;&#41;&#41;, &#91;Sym&#40;:z&#41;, Sym&#40;:y&#41;&#93;&#41;&#41;, # I₆
         Assign&#40;Sym&#40;:x&#41;, Call&#40;Sym&#40;:&#40;&#43;&#41;&#41;, &#91;Sym&#40;:x&#41;, Num&#40;1&#41;&#93;&#41;&#41;,  # I₇
         GotoIf&#40;4, Call&#40;Sym&#40;:&#40;&lt;&#41;&#41;, &#91;Sym&#40;:x&#41;, Num&#40;10&#41;&#93;&#41;&#41;,       # I₈
         &#93;::Program</code></pre></p>
<p><pre><code class="plaintext code-output">9-element Vector{Instr}:
 Assign(Sym(:x), Num(1))
 Assign(Sym(:y), Num(2))
 Assign(Sym(:z), Num(3))
 Goto(8)
 Assign(Sym(:r), Call(Sym(:+), Exp[Sym(:y), Sym(:z)]))
 GotoIf(7, Call(Sym(:≤), Exp[Sym(:x), Sym(:z)]))
 Assign(Sym(:r), Call(Sym(:+), Exp[Sym(:z), Sym(:y)]))
 Assign(Sym(:x), Call(Sym(:+), Exp[Sym(:x), Num(1)]))
 GotoIf(4, Call(Sym(:<), Exp[Sym(:x), Num(10)]))</code></pre></p>
<p>Hm, it&#39;s a little clumsy. So, let&#39;s write a macro <code>@prog</code> that generates our target instruction-level problem \(P\) from Julia syntax, using Julia&#39;s powerful meta-programming features<sup id="fnref:4"><a href="#fndef:4" class=fnref >[4]</a></sup>. We&#39;ll use <a href="https://github.com/FluxML/MacroTools.jl">MacroTools.jl</a>, a package for pattern-matching on Julia&#39;s <a href="https://docs.julialang.org/en/v1/devdocs/ast/#Surface-syntax-AST">surface syntax AST</a>.</p>
<pre><code class=language-julia >using MacroTools

macro prog&#40;blk&#41;
    Instr&#91;Instr&#40;x&#41; for x in filter&#40;&#33;islnn, blk.args&#41;&#93;::Program
end

function Instr&#40;x&#41;
    if @capture&#40;x, lhs_ &#61; rhs_&#41;               # &#61;&gt; Assign
        Assign&#40;Instr&#40;lhs&#41;, Instr&#40;rhs&#41;&#41;
    elseif @capture&#40;x, @goto label_&#41;          # &#61;&gt; Goto
        Goto&#40;label&#41;
    elseif @capture&#40;x, cond_ &amp;&amp; @goto label_&#41; # &#61;&gt; GotoIf
        GotoIf&#40;label, Instr&#40;cond&#41;&#41;
    elseif @capture&#40;x, f_&#40;args__&#41;&#41;            # &#61;&gt; Call
        Call&#40;Instr&#40;f&#41;, Instr.&#40;args&#41;&#41;
    elseif isa&#40;x, Symbol&#41;                     # &#61;&gt; Sym
        Sym&#40;x&#41;
    elseif isa&#40;x, Int&#41;                        # &#61;&gt; Num
        Num&#40;x&#41;
    else
        error&#40;&quot;invalid expression: &#36;&#40;x&#41;&quot;&#41;
    end
end

islnn&#40;@nospecialize&#40;_&#41;&#41; &#61; false
islnn&#40;::LineNumberNode&#41; &#61; true</code></pre></p>
<p><pre><code class="plaintext code-output">islnn (generic function with 2 methods)</code></pre>
<p>Now we can generate \(P\) directly from Julia&#39;s nice syntax :-&#41; <pre><code class=language-julia >prog0 &#61; @prog begin
    x &#61; 1             # I₀
    y &#61; 2             # I₁
    z &#61; 3             # I₂
    @goto 8           # I₃
    r &#61; y &#43; z         # I₄
    x ≤ z &amp;&amp; @goto 7  # I₅
    r &#61; z &#43; y         # I₆
    x &#61; x &#43; 1         # I₇
    x &lt; 10 &amp;&amp; @goto 4 # I₈
end</code></pre></p>
<p><pre><code class="plaintext code-output">9-element Vector{Instr}:
 Assign(Sym(:x), Num(1))
 Assign(Sym(:y), Num(2))
 Assign(Sym(:z), Num(3))
 Goto(8)
 Assign(Sym(:r), Call(Sym(:+), Exp[Sym(:y), Sym(:z)]))
 GotoIf(7, Call(Sym(:≤), Exp[Sym(:x), Sym(:z)]))
 Assign(Sym(:r), Call(Sym(:+), Exp[Sym(:z), Sym(:y)]))
 Assign(Sym(:x), Call(Sym(:+), Exp[Sym(:x), Num(1)]))
 GotoIf(4, Call(Sym(:<), Exp[Sym(:x), Num(10)]))</code></pre></p>
<h2 id=the_graph-free_algorithm__2 ><a href="#the_graph-free_algorithm__2" class=header-anchor >The graph-free algorithm</a></h2>
<p>Okay, it&#39;s time to implement the main algorithm. If we try to implement it faithfully according to the paper, it would look like this: <pre><code class=language-julia >function max_fixed_point&#40;prog::Program, a₀::AbstractState, eval&#41;
    n &#61; length&#40;prog&#41;
    init &#61; AbstractState&#40; v &#61;&gt; ⊤ for v in keys&#40;a₀&#41; &#41;
    s &#61; &#91; a₀; &#91; init for i &#61; 2:n &#93; &#93;
    W &#61; BitSet&#40;0:n-1&#41;

    while &#33;isempty&#40;W&#41;
        pc &#61; first&#40;W&#41;
        while pc ≠ n
            delete&#33;&#40;W, pc&#41;
            I &#61; prog&#91;pc&#43;1&#93;
            new &#61; s&#91;pc&#43;1&#93;
            if isa&#40;I, Assign&#41;
                # for an assignment, outgoing value is different from incoming
                new &#61; copy&#40;new&#41;
                new&#91;I.lhs.name&#93; &#61; eval&#40;I.rhs, new&#41;
            end

            if isa&#40;I, Goto&#41;
                pc´ &#61; I.label
            else
                pc´ &#61; pc&#43;1
                if isa&#40;I, GotoIf&#41;
                    l &#61; I.label
                    if new &lt; s&#91;l&#43;1&#93;
                        push&#33;&#40;W, l&#41;
                        s&#91;l&#43;1&#93; &#61; new
                    end
                end
            end
            if pc´≤n-1 &amp;&amp; new &lt; s&#91;pc´&#43;1&#93;
                s&#91;pc´&#43;1&#93; &#61; new
                pc &#61; pc´
            else
                pc &#61; n
            end
        end
    end

    return s
end</code></pre></p>
<p><pre><code class="plaintext code-output">max_fixed_point (generic function with 1 method)</code></pre></p>
<p>Note that in this article we&#39;re trying to express things in the same way as the paper as possible, and so here we&#39;ve adjusted the paper&#39;s <code>0</code>-based indexing so that it fits with Julia&#39;s <code>1</code>-based indexing as <code>s&#91;pc´&#43;1&#93;</code> and so on.</p>
<p>Now we&#39;re good to go, let&#39;s run it on <code>prog0</code> &#33;</p>
<pre><code class=language-julia >max_fixed_point&#40;prog0, a₀, abstract_eval&#41;</code></pre></p>
<p><pre><code class="plaintext code-output">9-element Vector{Dict{Symbol, LatticeElement}}:
 Dict(:y => ⊤, :z => ⊤, :r => ⊤, :x => ⊤)
 Dict(:y => ⊤, :z => ⊤, :r => ⊤, :x => Const(1))
 Dict(:y => Const(2), :z => ⊤, :r => ⊤, :x => Const(1))
 Dict(:y => Const(2), :z => Const(3), :r => ⊤, :x => Const(1))
 Dict(:y => Const(2), :z => Const(3), :r => ⊤, :x => Const(1))
 Dict(:y => Const(2), :z => Const(3), :r => Const(5), :x => Const(1))
 Dict(:y => Const(2), :z => Const(3), :r => Const(5), :x => Const(1))
 Dict(:y => Const(2), :z => Const(3), :r => Const(5), :x => Const(1))
 Dict(:y => Const(2), :z => Const(3), :r => ⊤, :x => Const(1))</code></pre>
<p>... Hmm ? The result is different from <a href="#tracing-example">the paper&#39;s tracing example</a>. See the last line <code>Dict&#40;:y &#61;&gt; Const&#40;2&#41;, :z &#61;&gt; Const&#40;3&#41;, :r &#61;&gt; ⊤, :x &#61;&gt; Const&#40;1&#41;&#41;</code>, which corresponds to \(s_8\) in the tracing example, and there&#39;s no longer any information that indicates <code>r</code> is a constant <code>5</code> at that point.</p>
<p>To say the conclusion first, this is in fact because the paper&#39;s original algorithm is partially wrong<sup id="fnref:5"><a href="#fndef:5" class=fnref >[5]</a></sup>. Let&#39;s take a close look.</p>
<p>Actually, the tracing example from the paper is incomplete. If we run the algorithm, at the cell at the 5th row from the top and 11th column from the left, which is blank in the original table, \(s_3\) &#40;the state of <code>I₃ &#61; goto I₈</code>&#41; should have propagated to \(s_8\) &#40;the state of <code>I₈ &#61; if x &lt; 10 goto I₄</code>&#41;, and so the cell should have been \(s_8 := \text{x}/1 \text{y}/2 \text{z}/3 \text{r}/\top\). Then at the cell at 11th row from the top and 10th column from the left, \(s_8 < s_7\) no longer holds, and thus \(s_7\) &#40;the state of <code>I₇ &#61; x :&#61; x &#43; 1</code>&#41; won&#39;t be propagated to \(s_8\) and \(W\) will be emptied, and consequently, the algorithm will terminate at that point.</p>
<p>Since the implementation above faithfully follows the paper, it terminated as exactly described above &#40;i.e. <code>new &lt; s&#91;pc´&#43;1&#93;</code> didn&#39;t returns <code>true</code> when <code>new</code> is \(s_7\)&#41;. Now we&#39;re in trouble ...</p>
<h2 id=debugging_the_papers_algorithm ><a href="#debugging_the_papers_algorithm" class=header-anchor >Debugging the paper&#39;s algorithm</a></h2>
<p>The problem with the paper&#39;s algorithm is that, to put it simply, the states can&#39;t propagate well if we use strict ordering relation between abstract states <span class=eqref >(<a href="#strict_ordering_relation_between_abstract_states">3</a>)</span> to determine whether or not the abstract state of the current instruction changes an abstract state to which it propagates.</p>
<p>In this particular case, while the ordering relation <code>new &lt; s&#91;pc´&#43;1&#93;</code> doesn&#39;t hold when <code>new</code> is \(s_7\) &#40;abstract state of the current instruction \(I_7\), \(\text{x}/2 \text{y}/2 \text{z}/3 \text{r}/5\)&#41; and <code>s&#91;pc´&#43;1&#93;</code> is \(s_8\) &#40;abstract state of the next instruction \(I_8\), \(\text{x}/1 \text{y}/2 \text{z}/3 \text{r}/\top\)&#41;, but we still want to propagate <code>new</code> &#40;\(s_7\)&#41; to <code>s&#91;pc´&#43;1&#93;</code> &#40;\(s_8\)&#41; and update <code>s&#91;pc´&#43;1&#93;</code> to such an new state that \(s_8 := \text{x}/\bot \text{y}/2 \text{z}/3 \text{r}/5\).</p>
<p>Therefore, we want to fix the original algorithm so that:</p>
<ol>
<li><p>it propagates changes of the current instruction&#39;s state \(new\) to the next instruction&#39;s state \(s_{pc'}\), <em>without</em> using their strict ordering relation \(new < s_{pc'} \equiv (new \sqcap s_{pc'} = new) \land (new \ne s_{pc'})\) <span class=eqref >(<a href="#strict_ordering_relation_between_abstract_states">3</a>)</span></p>

<li><p>on the other hand, in order to keep the convergence of the algorithm, changes of \(new\) should be propagated in a way that <em>the new state always is lower in the lattice \(L\) than the previous state</em></p>

</ol>
<p>We can put them into code as follows:</p>
<ol>
<li><p>use the &quot;equivalence&quot; of abstract state to determine whether or not the abstract state of the current instruction changes an abstract state to which it propagates</p>

<li><p>use <code>⊓</code> &#40;meet, computes maximum lower bound&#41; to update abstract state, to make sure that the updated abstract state will be lower in \(L\) than the previous state.</p>

</ol>
<p>So, let&#39;s apply the following diff to <code>max_fixed_point</code>:</p>
<pre><code class=language-diff >--- a/dataflow.jl
&#43;&#43;&#43; b/dataflow.jl
@@ -156,14 &#43;156,14 @@ function max_fixed_point&#40;prog::Program, a₀::AbstractState, eval&#41;
                 pc´ &#61; pc&#43;1
                 if isa&#40;I, GotoIf&#41;
                     l &#61; I.label
-                    if new &lt; s&#91;l&#43;1&#93;
&#43;                    if new ≠ s&#91;l&#43;1&#93;
                         push&#33;&#40;W, l&#41;
-                        s&#91;l&#43;1&#93; &#61; new
&#43;                        s&#91;l&#43;1&#93; &#61; new ⊓ s&#91;l&#43;1&#93;
                     end
                 end
             end
-            if pc´≤n-1 &amp;&amp; new &lt; s&#91;pc´&#43;1&#93;
-                s&#91;pc´&#43;1&#93; &#61; new
&#43;            if pc´≤n-1 &amp;&amp; new ≠ s&#91;pc´&#43;1&#93;
&#43;                s&#91;pc´&#43;1&#93; &#61; new ⊓ s&#91;pc´&#43;1&#93;
                 pc &#61; pc´
             else
                 pc &#61; n</code></pre>
<h2 id=the_modified_version_of_the_graph-free_algorithm ><a href="#the_modified_version_of_the_graph-free_algorithm" class=header-anchor >The modified version of the graph-free algorithm</a></h2>
<p>Let&#39;s try the modified version of the algorithm: <pre><code class=language-julia ># NOTE: in this problem, we make sure that states will always move to _lower_ position in lattice, so
# - initialize states with &#96;⊤&#96;
# - we use &#96;⊓&#96; &#40;meet&#41; operator to update states,
# - and the condition we use to check whether or not the statement makes a change is &#96;new ≠ prev&#96;
function max_fixed_point&#40;prog::Program, a₀::AbstractState, eval&#41;
    n &#61; length&#40;prog&#41;
    init &#61; AbstractState&#40; v &#61;&gt; ⊤ for v in keys&#40;a₀&#41; &#41;
    s &#61; &#91; a₀; &#91; init for i &#61; 2:n &#93; &#93;
    W &#61; BitSet&#40;0:n-1&#41;

    while &#33;isempty&#40;W&#41;
        pc &#61; first&#40;W&#41;
        while pc ≠ n
            delete&#33;&#40;W, pc&#41;
            I &#61; prog&#91;pc&#43;1&#93;
            new &#61; s&#91;pc&#43;1&#93;
            if isa&#40;I, Assign&#41;
                # for an assignment, outgoing value is different from incoming
                new &#61; copy&#40;new&#41;
                new&#91;I.lhs.name&#93; &#61; eval&#40;I.rhs, new&#41;
            end

            if isa&#40;I, Goto&#41;
                pc´ &#61; I.label
            else
                pc´ &#61; pc&#43;1
                if isa&#40;I, GotoIf&#41;
                    l &#61; I.label
                    if new ≠ s&#91;l&#43;1&#93;
                        push&#33;&#40;W, l&#41;
                        s&#91;l&#43;1&#93; &#61; new ⊓ s&#91;l&#43;1&#93;
                    end
                end
            end
            if pc´≤n-1 &amp;&amp; new ≠ s&#91;pc´&#43;1&#93;
                s&#91;pc´&#43;1&#93; &#61; new ⊓ s&#91;pc´&#43;1&#93;
                pc &#61; pc´
            else
                pc &#61; n
            end
        end
    end

    return s
end

max_fixed_point&#40;prog0, a₀, abstract_eval&#41; # The solution contains the &#96;:r &#61;&gt; Const&#40;5&#41;&#96;, which is not found in the program</code></pre></p>
<p><pre><code class="plaintext code-output">9-element Vector{Dict{Symbol, LatticeElement}}:
 Dict(:y => ⊤, :z => ⊤, :r => ⊤, :x => ⊤)
 Dict(:y => ⊤, :z => ⊤, :r => ⊤, :x => Const(1))
 Dict(:y => Const(2), :z => ⊤, :r => ⊤, :x => Const(1))
 Dict(:y => Const(2), :z => Const(3), :r => ⊤, :x => Const(1))
 Dict(:y => Const(2), :z => Const(3), :r => Const(5), :x => ⊥)
 Dict(:y => Const(2), :z => Const(3), :r => Const(5), :x => ⊥)
 Dict(:y => Const(2), :z => Const(3), :r => Const(5), :x => ⊥)
 Dict(:y => Const(2), :z => Const(3), :r => Const(5), :x => ⊥)
 Dict(:y => Const(2), :z => Const(3), :r => Const(5), :x => ⊥)</code></pre></p>
<p>Hooray &#33; Splendidly, the algorithm&#39;s returned <code>Dict&#40;:y &#61;&gt; Const&#40;2&#41;, :z &#61;&gt; Const&#40;3&#41;, :r &#61;&gt; Const&#40;5&#41;, :x &#61;&gt; ⊥&#41;</code>, which corresponds to \(s_8\), and now we know <code>r</code> is a constant <code>5</code> correctly.</p>
<h1 id=compare_with_julias_native_type_inference ><a href="#compare_with_julias_native_type_inference" class=header-anchor >Compare with Julia&#39;s native type inference</a></h1>
<p>By the way, Julia&#39;s type inference consists of two major parts:</p>
<ul>
<li><p>part 1. local inference within the scope of a function</p>

<li><p>part 2. inter-procedural inference across function calls</p>

</ul>
<p>The part 1 is the core subroutine of Julia&#39;s type inference and is based on the algorithm proposed in <span class=bibref ><a href="#graphfree">Mohnen, M., 2002, April. A graph-free approach to data-flow analysis</a></span>, that now we know how it works. The part 2 extends it so that the inference still converges even when it recurs into a function calls in the inter-procedural way &#40;even if there is mutual recursive calls, etc.&#41;. This article won&#39;t go any further on the part 2, please refer to <span class=bibref ><a href="#phdthesis">Jeff Bezanson's Ph.D. thesis</a></span> or <span class=bibref ><a href="#blogbost">Jameson Nash's blog post</a></span> for details if interested.</p>
<p>So we may be interested in if Julia’s type inference also modifies the paper&#39;s original algorithm as well as this article. For example, does it work for <code>prog0</code> correctly ?</p>
<h2 id=try_it_first ><a href="#try_it_first" class=header-anchor >Try it first</a></h2>
<p>Julia&#39;s type inference routine uses data-flow analysis to type-annotate your Julia code in order to generate efficient code. It actually does constant prop&#39; to improve the accuracy of inference. So if Julia&#39;s type inference routine works correctly, it should reveal that <code>r</code> in <code>prog0</code> is a constant <code>5</code>.</p>
<p>Let&#39;s create Julia code corresponding to <code>prog0</code> and run type inference on it. We can express <code>prog0</code> as Julia code using <a href="https://docs.julialang.org/en/v1/base/base/#Base.@label"><code>@label</code></a> macro:</p>
<pre><code class=language-julia >begin
    begin
        @label I₀
        x &#61; 1
    end
    ...
    begin
        @label I₅
        x ≤ z &amp;&amp; @goto I₇
    end
    ...
end</code></pre>
<p>Again, it&#39;s a bit ugly, so let&#39;s define <code>@prog′</code> macro that generates valid Julia code from our \(P = I_0 ... I_n \in \text{Instr}\) notations &#40;i.e. the syntax <code>@prog</code> works on&#41;: <pre><code class=language-julia ># generate valid Julia code from the &quot;&#96;Instr&#96; syntax&quot;
macro prog′&#40;blk&#41;
    prog′ &#61; Expr&#40;:block&#41;
    bns &#61; &#91;gensym&#40;Symbol&#40;:instruction, i-1&#41;&#41; for i in 1:length&#40;blk.args&#41;&#93; # pre-generate labels for all instructions

    for &#40;i,x&#41; in enumerate&#40;filter&#40;&#33;islnn, blk.args&#41;&#41;
        x &#61; MacroTools.postwalk&#40;x&#41; do x
            return if @capture&#40;x, @goto label_&#41;
                Expr&#40;:symbolicgoto, bns&#91;label&#43;1&#93;&#41; # fix &#96;@goto i&#96; into valid goto syntax
            else
                x
            end
        end

        push&#33;&#40;prog′.args, Expr&#40;:block, Expr&#40;:symboliclabel, bns&#91;i&#93;&#41;, x&#41;&#41; # label this statement
    end

    return prog′
end

@macroexpand @prog′ begin
    x &#61; 1             # I₀
    y &#61; 2             # I₁
    z &#61; 3             # I₂
    @goto 8           # I₃
    r &#61; y &#43; z         # I₄
    x ≤ z &amp;&amp; @goto 7  # I₅
    r &#61; z &#43; y         # I₆
    x &#61; x &#43; 1         # I₇
    x &lt; 10 &amp;&amp; @goto 4 # I₈
end</code></pre></p>
<p><pre><code class="plaintext code-output">quote
    begin
        $(Expr(:symboliclabel, Symbol("#45###instruction0#278")))
        var"#57#x" = 1
    end
    begin
        $(Expr(:symboliclabel, Symbol("#46###instruction1#279")))
        var"#54#y" = 2
    end
    begin
        $(Expr(:symboliclabel, Symbol("#47###instruction2#280")))
        var"#55#z" = 3
    end
    begin
        $(Expr(:symboliclabel, Symbol("#48###instruction3#281")))
        $(Expr(:symbolicgoto, Symbol("#49###instruction8#286")))
    end
    begin
        $(Expr(:symboliclabel, Symbol("#50###instruction4#282")))
        var"#56#r" = var"#54#y" + var"#55#z"
    end
    begin
        $(Expr(:symboliclabel, Symbol("#51###instruction5#283")))
        var"#57#x" ≤ var"#55#z" && $(Expr(:symbolicgoto, Symbol("#52###instruction7#285")))
    end
    begin
        $(Expr(:symboliclabel, Symbol("#53###instruction6#284")))
        var"#56#r" = var"#55#z" + var"#54#y"
    end
    begin
        $(Expr(:symboliclabel, Symbol("#52###instruction7#285")))
        var"#57#x" = var"#57#x" + 1
    end
    begin
        $(Expr(:symboliclabel, Symbol("#49###instruction8#286")))
        var"#57#x" < 10 && $(Expr(:symbolicgoto, Symbol("#50###instruction4#282")))
    end
end</code></pre></p>
<p>As we can see <code>@prog′</code> nicely generates valid Julia code corresponding to <code>prog0</code> from our notation :&#41;</p>
<p>Okay, let&#39;s check the result of Julia&#39;s native type inference using <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a>: <pre><code class=language-julia >code_typed&#40;; optimize &#61; false&#41; do
    @prog′ begin
        x &#61; 1             # I₀
        y &#61; 2             # I₁
        z &#61; 3             # I₂
        @goto 8           # I₃
        r &#61; y &#43; z         # I₄
        x ≤ z &amp;&amp; @goto 7  # I₅
        r &#61; z &#43; y         # I₆
        x &#61; x &#43; 1         # I₇
        x &lt; 10 &amp;&amp; @goto 4 # I₈

        x, y, z, r # to check the result of abstract interpretation
    end
end |&gt; first</code></pre></p>
<p><pre><code class="plaintext code-output">CodeInfo(
1 ─       Core.NewvarNode(:(r))::Any
│         (x = 1)::Core.Const(1)
│         (y = 2)::Core.Const(2)
│         (z = 3)::Core.Const(3)
└──       goto #6
2 ─       (r = y::Core.Const(2) + z::Core.Const(3))::Core.Const(5)
│   %7  = (x ≤ z::Core.Const(3))::Bool
└──       goto #4 if not %7
3 ─       goto #5
4 ─       (r = z::Core.Const(3) + y::Core.Const(2))::Core.Const(5)
5 ┄       (x = x + 1)::Int64
6 ┄ %12 = (x < 10)::Bool
└──       goto #8 if not %12
7 ─       goto #2
8 ─ %15 = Core.tuple(x, y::Core.Const(2), z::Core.Const(3), r::Core.Const(5))::Core.PartialStruct(NTuple{4, Int64}, Any[Int64, Core.Const(2), Core.Const(3), Core.Const(5)])
└──       return %15
) => NTuple{4, Int64}</code></pre></p>
<p>As seen in the line <code>8 ─ &#37;15 &#61; Core.tuple&#40;x, y::Core.Const&#40;2&#41;, z::Core.Const&#40;3&#41;, r::Core.Const&#40;5&#41;&#41;::Core.PartialStruct&#40;NTuple&#123;4, Int64&#125;, Any&#91;Int64, Core.Const&#40;2&#41;, Core.Const&#40;3&#41;, Core.Const&#40;5&#41;&#93;&#41;</code>, Julia&#39;s data-flow analysis correctly reveals that <code>r</code> is a constant <code>5</code> &#40;i.e. <code>r::Core.Const&#40;5&#41;</code> in Julia&#39;s internal representation&#41;.</p>
<div class=collapsible ><div class=collapsible-header >Run it actually</div>
<div class=collapsible-content ><p>If we actually execute <code>prog0</code>, we get the result <code>r &#61;&#61; 5</code> as expected: <pre><code class=language-julia >@prog′ begin
    x &#61; 1             # I₀
    y &#61; 2             # I₁
    z &#61; 3             # I₂
    @goto 8           # I₃
    r &#61; y &#43; z         # I₄
    x ≤ z &amp;&amp; @goto 7  # I₅
    r &#61; z &#43; y         # I₆
    x &#61; x &#43; 1         # I₇
    x &lt; 10 &amp;&amp; @goto 4 # I₈

    x, y, z, r # to check the result of actual execution
end</code></pre></p>
<p><pre><code class="plaintext code-output">(10, 2, 3, 5)</code></pre></p></div></div>
<h2 id=check_the_fixes_in_julias_type_inference_implementation ><a href="#check_the_fixes_in_julias_type_inference_implementation" class=header-anchor >Check the fixes in Julia&#39;s type inference implementation</a></h2>
<p>So Julia&#39;s type inference correctly works on <code>prog0</code>, and now we&#39;re interested in how it&#39;s different from the original algorithm proposed in the paper. Let&#39;s have a quick dive into Julia&#39;s type inference implementation.</p>
<p>To help you understand, I&#39;m going to present the parts in Julia&#39;s data-flow analysis implementation that correspond to the fixes we&#39;ve made in this article:</p>
<blockquote>
<ol>
<li><p>use the &quot;equivalence&quot; of abstract state to determine whether or not the abstract state of the current instruction changes an abstract state to which it propagates</p>

<li><p>use <code>⊓</code> &#40;meet, computes maximum lower bound&#41; to update abstract state, to make sure that the updated abstract state will be lower in \(L\) than the previous state.</p>

</ol>
</blockquote>
<div class=caption >The fixes we&#39;ve made</div>
<p>Please keep in mind that there&#39;re two notable differences between our constant folding prop&#39; problem and Julia&#39;s type inference:</p>
<ol>
<li><p>our constant folding prop&#39; compares abstract state \(A\) to determine the convergence of state, while Julia&#39;s type inference compares abstract value \(C\) &#40;, which corresponds to <code>LatticeElement</code> in our implementation&#41;</p>

<li><p>Julia&#39;s type inference and our constant folding prop&#39; works on their own lattice in the opposite directions; unlike our constant folding prop&#39; setup, Julia&#39;s type inference transitions abstract value \(C\)  <em>from \(\bot\) to \(\top\)</em><sup id="fnref:6"><a href="#fndef:6" class=fnref >[6]</a></sup></p>

</ol>
<div class=warning ><div class=admonition-header >Maybe outdated</div>
<div class=admonition-body >The code I&#39;m going to show or refer to below was all take from <a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd">this commit</a>     of the <a href="https://github.com/JuliaLang/julia">JuliaLang/julia repository</a>.</div></div>
<h3 id=fix_1_the_condition_to_determine_the_convergence_of_abstract_state ><a href="#fix_1_the_condition_to_determine_the_convergence_of_abstract_state" class=header-anchor >Fix 1: The condition to determine the convergence of abstract state</a></h3>
<p>In Julia&#39;s type inference implementation, <a href="https://github.com/JuliaLang/julia/blob/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/abstractinterpretation.jl#L1260-L1438"><code>typeinf_local</code></a> corresponds to the paper&#39;s algorithm. Within <code>typeinf_local</code>, abstract states are updated in the following parts:</p>
<ol>
<li><p><a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/abstractinterpretation.jl#L1316">https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/abstractinterpretation.jl#L1316</a>: <code>newstate_else &#61; stupdate&#33;&#40;s&#91;l&#93;, changes_else&#41;</code></p>

<li><p><a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/abstractinterpretation.jl#L1415">https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/abstractinterpretation.jl#L1415</a>: <code>newstate &#61; stupdate&#33;&#40;s&#91;pc´&#93;, changes&#41;</code></p>

</ol>
<p>Here is how <code>stupdate&#33;</code> is implemented:</p>
<pre><code class=language-julia >function stupdate&#33;&#40;state::VarTable, changes::StateUpdate&#41;
    if &#33;isa&#40;changes.var, Slot&#41;
        return stupdate&#33;&#40;state, changes.state&#41;
    end
    newstate &#61; false
    changeid &#61; slot_id&#40;changes.var::Slot&#41;
    for i &#61; 1:length&#40;state&#41;
        if i &#61;&#61; changeid
            newtype &#61; changes.vtype
        else
            newtype &#61; changes.state&#91;i&#93;
        end
        oldtype &#61; state&#91;i&#93;
        # remove any Conditional for this Slot from the vtable
        if isa&#40;newtype, VarState&#41;
            newtypetyp &#61; newtype.typ
            if isa&#40;newtypetyp, Conditional&#41; &amp;&amp; slot_id&#40;newtypetyp.var&#41; &#61;&#61; changeid
                newtype &#61; VarState&#40;widenconditional&#40;newtypetyp&#41;, newtype.undef&#41;
            end
        end
        if schanged&#40;newtype, oldtype&#41;
            newstate &#61; state
            state&#91;i&#93; &#61; smerge&#40;oldtype, newtype&#41;
        end
    end
    return newstate
end

function stupdate&#33;&#40;state::VarTable, changes::VarTable&#41;
    newstate &#61; false
    for i &#61; 1:length&#40;state&#41;
        newtype &#61; changes&#91;i&#93;
        oldtype &#61; state&#91;i&#93;
        if schanged&#40;newtype, oldtype&#41;
            newstate &#61; state
            state&#91;i&#93; &#61; smerge&#40;oldtype, newtype&#41;
        end
    end
    return newstate
end</code></pre>
<div class=caption ><blockquote>
<p><a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L268-L307">https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L268-L307</a></p>
</blockquote></div>
<p><code>schanged</code> seems to take the role to determine the convergence of abstract value. Let&#39;s take a closer look at <code>schanged</code>:</p>
<pre><code class=language-julia >@inline schanged&#40;@nospecialize&#40;n&#41;, @nospecialize&#40;o&#41;&#41; &#61; &#40;n &#33;&#61;&#61; o&#41; &amp;&amp; &#40;o &#61;&#61;&#61; NOT_FOUND || &#40;n &#33;&#61;&#61; NOT_FOUND &amp;&amp; &#33;issubstate&#40;n, o&#41;&#41;&#41;</code></pre>
<div class=caption ><blockquote>
<p><a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L236">https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L236</a></p>
</blockquote></div>
<pre><code class=language-julia >issubstate&#40;a::VarState, b::VarState&#41; &#61; &#40;a.typ ⊑ b.typ &amp;&amp; a.undef &lt;&#61; b.undef&#41;</code></pre>
<div class=caption ><blockquote>
<p><a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L224">https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L224</a></p>
</blockquote></div>
<p>where <a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L115-L186"><code>⊑</code></a> computes the partial order of abstract values in Julia&#39;s type lattice.</p>
<p>Comparing to our setup, to update abstract values when <code>schanged&#40;n, o&#41;</code> holds in Julia&#39;s type inference corresponds to updating abstract states when <code>&#33;&#40;new ≥ s&#91;pc´&#43;1&#93;&#41;</code> holds &#40;instead of when <code>new &lt; s&#91;pc´&#43;1&#93;</code> holds&#41; in our code<sup id="fnref:7"><a href="#fndef:7" class=fnref >[7]</a></sup>. Note that in our setup <code>new</code> is actually never greater than <code>s&#91;pc´&#43;1&#93;</code>, thus <code>&#33;&#40;new ≥ s&#91;pc´&#43;1&#93;&#41;</code> essentially equals to <code>new ≠ s&#91;pc´&#43;1&#93;</code>.</p>
<p>Well, as I said, <code>schanged</code> works on abstract <em>values</em> rather than abstract <em>states</em>, unlike <code>≠&#40;::AbstractState, ::AbstractState&#41;</code> in our constant folding prop&#39; setup. But there is no essential difference between them, since our constant folding prop&#39; implementation updates abstract states by variable-wise use of <code>⊓</code> and so <code>≠&#40;::AbstractState, ::AbstractState&#41;</code> returns <code>false</code> only after all abstract values for each variable have converged to their fixed point.</p>
<p>Anyway, we can see Julia&#39;s type inference analysis implementation also changes the paper&#39;s original convergence condition, and uses <code>&#33;⊑</code> instead of <code>⊐</code> as our <code>max_fixed_point</code> uses <code>≠</code> instead of <code>&lt;</code>.</p>
<h3 id=fix_2_how_to_update_abstract_state ><a href="#fix_2_how_to_update_abstract_state" class=header-anchor >Fix 2: How to update abstract state</a></h3>
<p><code>smerge</code> updates abstract value:</p>
<pre><code class=language-julia >function smerge&#40;sa::Union&#123;NotFound,VarState&#125;, sb::Union&#123;NotFound,VarState&#125;&#41;
    sa &#61;&#61;&#61; sb &amp;&amp; return sa
    sa &#61;&#61;&#61; NOT_FOUND &amp;&amp; return sb
    sb &#61;&#61;&#61; NOT_FOUND &amp;&amp; return sa
    issubstate&#40;sa, sb&#41; &amp;&amp; return sb
    issubstate&#40;sb, sa&#41; &amp;&amp; return sa
    return VarState&#40;tmerge&#40;sa.typ, sb.typ&#41;, sa.undef | sb.undef&#41;
end</code></pre>
<div class=caption ><blockquote>
<p><a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L226-L233">https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelattice.jl#L226-L233</a></p>
</blockquote></div>
<p>Although <code>smerge</code> looks a bit involved, <code>tmerge</code> seems to be taking the heavy lifting to update abstract values. Well, <a href="https://github.com/JuliaLang/julia/tree/f2eb09e5da50128af1f2b20a451dadd3adc991fd/base/compiler/typelimits.jl#L284-L448"><code>tmerge</code> is yet more complex</a> and so I&#39;d like to omit its detail here, but it basically performs the operation that is equivalent to \(\sqcup\) &#40;join&#41;, which also corresponds to our fix <sup id="fnref:8"><a href="#fndef:8" class=fnref >[8]</a></sup>.</p>
<p>After all, Julia&#39;s type inference implementation bases on the algorithm proposed in the paper but also it fixes the originally proposed algorithm as we&#39;ve done for constant folding prop&#39; problem in this article.</p>
<h1 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h1>
<p>In this article, we have implemented the data-flow analysis algorithm proposed in <span class=bibref ><a href="#graphfree">Mohnen, M., 2002, April. A graph-free approach to data-flow analysis</a></span>, that Julia&#39;s type inference routine is based on. While implementing the example data-flow problem, we found some minor &#40;yet super serious &#33;&#41; mistakes in the paper, and we saw there&#39;re similar changes done in Julia&#39;s type inference implementation; maybe the problems and fixes are only noticed by the readers of this article and the developers of Julia&#39;s compiler.</p>
<p>Well, it&#39;s the very first time for me to doubt and correct an academic paper; it actually took me a fair amount of time to get to this conclusion. <a href="https://akawashiro.github.io/">Akira Kawata</a> struggled with the paper together with me and helped me find and fix the problems. I would like to thank him again here.</p>
<h1 id=references ><a href="#references" class=header-anchor >References</a></h1>
<ul>
<li><p><a id=dataflowprob  class=anchor ></a><strong>Cousot, P.</strong> and <strong>Cousot, R.</strong>, 1977, January. <a href="https://doi.org/10.1145/512950.512973"><em>Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints</em></a>. In Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages &#40;pp. 238-252&#41;.</p>

<li><p><a id=bbgraph  class=anchor ></a><strong>Muchnick, S.S.</strong> and <strong>Jones, N.D.</strong>, 1981. <a href="https://www.researchgate.net/publication/220689271_Program_Flow_Analysis_Theory_and_Applications"><em>Program flow analysis: Theory and applications &#40;Vol. 196&#41;</em></a>. Englewood Cliffs, New Jersey: Prentice-Hall.</p>

<li><p><a id=graphfree  class=anchor ></a><strong>Mohnen, M.</strong>, 2002, April. <a href="https://api.semanticscholar.org/CorpusID:28519618"><em>A graph-free approach to data-flow analysis</em></a>. In International Conference on Compiler Construction &#40;pp. 46-61&#41;. Springer, Berlin, Heidelberg.</p>

<li><p><a id=phdthesis  class=anchor ></a><strong>Bezanson, J.W.</strong>, 2015. <a href="https://dspace.mit.edu/handle/1721.1/99811"><em>Abstraction in technical computing</em></a> &#40;Doctoral dissertation, Massachusetts Institute of Technology&#41;.</p>

<li><p><a id=blogbost  class=anchor ></a><strong>Nash, J.</strong>, 2017. <em>Inference Convergence Algorithm in Julia - Revisited</em>. Julia Computing.  &#91;online&#93; juliacomputing.com. Available at: <a href="https://juliacomputing.com/blog/2017/05/inference-converage2/">https://juliacomputing.com/blog/2017/05/inference-converage2/</a> &#91;Accessed 3 November 2020&#93;</p>

</ul>
<h1 id=footnotes ><a href="#footnotes" class=header-anchor >Footnotes</a></h1>
<p><table class=fndef  id="fndef:1">
    <tr>
        <td class=fndef-backref ><a href="#fnref:1">[1]</a>
        <td class=fndef-content >The paper uses <a href="https://www.compart.com/en/unicode/U&#43;1D56E">Unicode Character &quot;Lu_1D56E&quot; &#40;U&#43;1D56E&#41;</a> as a symbol for this, but in this article we&#39;ll use \(A\) instead of it since the character isn&#39;t supported by \(KaTeX\)
    
</table>
<table class=fndef  id="fndef:2">
    <tr>
        <td class=fndef-backref ><a href="#fnref:2">[2]</a>
        <td class=fndef-content >Of course this algorithm can be used for general data-flow problems other than the constant folding propagation problem we&#39;ve setup so far, but note that the initial state and inequalities in the algorithm can be different for each problem.
    
</table>
<table class=fndef  id="fndef:3">
    <tr>
        <td class=fndef-backref ><a href="#fnref:3">[3]</a>
        <td class=fndef-content >For conditional branching instruction, \(new\) is propagated to \(s_l\) &#40;abstract state of conditional jump destination instruction&#41; only when \(new\) is lower than \(s_l\) in the the lattice \(L\)
    
</table>
<table class=fndef  id="fndef:4">
    <tr>
        <td class=fndef-backref ><a href="#fnref:4">[4]</a>
        <td class=fndef-content >As an alternative, we can overload <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/"><code>Base.convert</code></a> and eliminates uses of constructors of <code>Sym</code> and <code>Num</code> by automatically promoting <code>Symbol</code> to <code>Sym</code> and <code>Int</code> to <code>Num</code>. A resulting code with this approach would look more like the code with our first naive approach to write \(P\) than the code with <code>@prog</code> macro.
    
</table>
<table class=fndef  id="fndef:5">
    <tr>
        <td class=fndef-backref ><a href="#fnref:5">[5]</a>
        <td class=fndef-content >By the way, there is no errata about this &#33;
    
</table>
<table class=fndef  id="fndef:6">
    <tr>
        <td class=fndef-backref ><a href="#fnref:6">[6]</a>
        <td class=fndef-content >Julia&#39;s type inference routine works on such a lattice that the more abstract types are at the top and the more concrete types are at the bottom &#40;where the most abstract type is <code>Any</code> and the most concrete type is <code>Union&#123;&#125;</code>&#41;, and transitions abstract value from \(\bot\) to \(\top\) &#40;, which is why Julia&#39;s type inference returns <code>Any</code> when it can&#39;t determine the type&#41;.
    
</table>
<table class=fndef  id="fndef:7">
    <tr>
        <td class=fndef-backref ><a href="#fnref:7">[7]</a>
        <td class=fndef-content >Note that <code>⊑</code> in Julia&#39;s type inference &quot;corresponds&quot; to <code>≥</code> in our constant folding prop&#39; setup, since they work on their lattice in the opposite direction.
    
</table>
<table class=fndef  id="fndef:8">
    <tr>
        <td class=fndef-backref ><a href="#fnref:8">[8]</a>
        <td class=fndef-content >Again, Julia&#39;s type inference transitions abstract value from \(\bot\) to \(\top\) as opposed to our constant folding prop&#39; setup, and so it should update abstract value using \(\sqcup\), which is the counterpart operation of \(\sqcap\).
    
</table>
</p>
<p></p>
<div class=page-foot >
  <div class=copyright >
    &copy; Shuhei Kadowaki. Last modified: 2022-01-17. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
     <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>
 
     <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>
 

    
    <script src="/libs/collapsible.js"></script>
<script src="/libs/lodash.js"></script>
<script src="/libs/onscroll.js"></script>


    
    
    <script>
      document.ontouchstart = () => {}
    </script>